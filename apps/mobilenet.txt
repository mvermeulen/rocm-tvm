[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 32, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 32, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((32,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 32, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 32, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((32,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 32, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 32, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_divide_2 = T.decl_buffer((32,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_multiply_2 = T.decl_buffer((32,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 32, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 32, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_negative_2 = T.decl_buffer((32,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_multiply_2 = T.decl_buffer((32,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 32, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 32, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 32, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_add_2 = T.decl_buffer((32,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 32, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 32, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((32,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 32, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 32, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((32,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 32, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 32, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_divide_2 = T.decl_buffer((32,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_multiply_2 = T.decl_buffer((32,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 32, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 32, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_negative_2 = T.decl_buffer((32,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:34] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_multiply_2 = T.decl_buffer((32,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 32, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 32, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 32, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    p1_2 = T.decl_buffer((32,), data=p1_1)
    T_add_2 = T.decl_buffer((32,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 64, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 64, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((64,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 64, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 64, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((64,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 64, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 64, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_divide_2 = T.decl_buffer((64,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_multiply_2 = T.decl_buffer((64,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 64, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 64, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_negative_2 = T.decl_buffer((64,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_multiply_2 = T.decl_buffer((64,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 64, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 64, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 64, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_add_2 = T.decl_buffer((64,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 64, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 64, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((64,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 64, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 64, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((64,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 64, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 64, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_divide_2 = T.decl_buffer((64,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_multiply_2 = T.decl_buffer((64,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 64, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 64, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_negative_2 = T.decl_buffer((64,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_multiply_2 = T.decl_buffer((64,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 64, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 64, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 64, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    p1_2 = T.decl_buffer((64,), data=p1_1)
    T_add_2 = T.decl_buffer((64,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:35] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 128, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 128, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((128,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 128, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 128, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_divide_2 = T.decl_buffer((128,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 128, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 128, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_negative_2 = T.decl_buffer((128,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 128, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 128, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 128, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((128,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 128, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 128, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_divide_2 = T.decl_buffer((128,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 128, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 128, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_negative_2 = T.decl_buffer((128,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 128, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 128, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 128, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((128,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:36] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 128, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 128, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_divide_2 = T.decl_buffer((128,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 128, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 128, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_negative_2 = T.decl_buffer((128,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 128, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 128, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 128, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((128,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 128, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 128, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_divide_2 = T.decl_buffer((128,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 128, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 128, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_negative_2 = T.decl_buffer((128,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_multiply_2 = T.decl_buffer((128,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 128, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 128, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 128, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    p1_2 = T.decl_buffer((128,), data=p1_1)
    T_add_2 = T.decl_buffer((128,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 256, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 256, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((256,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 256, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 256, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_divide_2 = T.decl_buffer((256,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:37] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 256, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 256, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_negative_2 = T.decl_buffer((256,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 256, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 256, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 256, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((256,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 256, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 256, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_divide_2 = T.decl_buffer((256,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 256, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 256, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_negative_2 = T.decl_buffer((256,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 256, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 256, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 256, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((256,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 256, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 256, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_divide_2 = T.decl_buffer((256,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 256, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 256, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_negative_2 = T.decl_buffer((256,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 256, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:38] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 256, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 256, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((256,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 256, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 256, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_divide_2 = T.decl_buffer((256,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 256, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 256, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_negative_2 = T.decl_buffer((256,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_multiply_2 = T.decl_buffer((256,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 256, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 256, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 256, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    p1_2 = T.decl_buffer((256,), data=p1_1)
    T_add_2 = T.decl_buffer((256,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:39] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:40] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:41] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:42] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:43] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 512, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 512, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((512,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 512, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 512, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_divide_2 = T.decl_buffer((512,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 512, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 512, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_negative_2 = T.decl_buffer((512,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_multiply_2 = T.decl_buffer((512,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 512, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 512, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 512, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    p1_2 = T.decl_buffer((512,), data=p1_1)
    T_add_2 = T.decl_buffer((512,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((1024,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 1024, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 1024, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_divide_2 = T.decl_buffer((1024,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:44] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 1024, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 1024, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_negative_2 = T.decl_buffer((1024,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 1024, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((1024,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 1024, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 1024, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_divide_2 = T.decl_buffer((1024,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 1024, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 1024, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_negative_2 = T.decl_buffer((1024,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 1024, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 0"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p1_3 = T.Buffer((1,), data=p1_1)
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + T.Broadcast(p1_3[0], 16)
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_sqrt(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_sqrt: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_sqrt_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_sqrt: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_sqrt_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_sqrt_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_p0_shape)
    intrp_fused_sqrt_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_sqrt_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_sqrt_1: T.handle("float32") = T.tvm_struct_get(T_sqrt, 0, 1, "handle")
    T.attr(T_sqrt_1, "storage_alignment", 64)
    intrp_fused_sqrt_T_sqrt_shape: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 2, "handle")
    intrp_fused_sqrt_T_sqrt_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_sqrt_T_sqrt_shape)
    intrp_fused_sqrt_T_sqrt_strides: T.handle("int64") = T.tvm_struct_get(T_sqrt, 0, 3, "handle")
    intrp_fused_sqrt_T_sqrt_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_sqrt_T_sqrt_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_sqrt: Expect arg[0] to be pointer"
    assert T_sqrt_code == 3 or T_sqrt_code == 13 or T_sqrt_code == 7 or T_sqrt_code == 4, "intrp_fused_sqrt: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_sqrt.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_p0_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_p0_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_p0_strides_1[0]), "intrp_fused_sqrt.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_sqrt.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_sqrt, 0, 4, "int32"), "intrp_fused_sqrt.T_sqrt.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_sqrt, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_sqrt, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_sqrt, 0, 7, "uint16") == T.uint16(1), "intrp_fused_sqrt.T_sqrt.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_sqrt_T_sqrt_shape_1[0]) == 1024, "Argument intrp_fused_sqrt.T_sqrt.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_sqrt_T_sqrt_shape[0])"
    if not T.isnullptr(intrp_fused_sqrt_T_sqrt_strides):
        assert 1 == T.Cast("int32", intrp_fused_sqrt_T_sqrt_strides_1[0]), "intrp_fused_sqrt.T_sqrt.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, "uint64"), "Argument intrp_fused_sqrt.T_sqrt.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_sqrt, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_sqrt, 0, 10, "int32") == 1, "Argument intrp_fused_sqrt.T_sqrt.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_sqrt, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_sqrt, 0, 9, "int32"), "Argument intrp_fused_sqrt.T_sqrt.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_sqrt, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_sqrt_2 = T.decl_buffer((1024,), data=T_sqrt_1)
    with T.attr(0, "compute_scope", "intrp_fused_sqrt_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_sqrt_2[cse_var_1:cse_var_1 + 16] = T.call_llvm_pure_intrin("float32x16", "llvm.sqrt", T.uint32(1), p0_2[cse_var_1:cse_var_1 + 16])
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_divide(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_divide: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_divide_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_divide: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_divide_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_divide_p0_shape_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_shape)
    intrp_fused_divide_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_divide_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_divide_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_divide_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_p1_shape)
    intrp_fused_divide_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_divide_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_p1_strides)
    T_divide_1: T.handle("float32") = T.tvm_struct_get(T_divide, 0, 1, "handle")
    T.attr(T_divide_1, "storage_alignment", 64)
    intrp_fused_divide_T_divide_shape: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 2, "handle")
    intrp_fused_divide_T_divide_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_divide_T_divide_shape)
    intrp_fused_divide_T_divide_strides: T.handle("int64") = T.tvm_struct_get(T_divide, 0, 3, "handle")
    intrp_fused_divide_T_divide_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_divide_T_divide_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_divide: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_divide: Expect arg[1] to be pointer"
    assert T_divide_code == 3 or T_divide_code == 13 or T_divide_code == 7 or T_divide_code == 4, "intrp_fused_divide: Expect arg[2] to be pointer"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert 0 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_divide.p0.ndim is expected to equal 0"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p0.dtype is expected to be float32"
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_divide.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_divide.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_p1_shape_1[0]) == 1024, "Argument intrp_fused_divide.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_p1_shape[0])"
    if not T.isnullptr(intrp_fused_divide_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_p1_strides_1[0]), "intrp_fused_divide.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_divide.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_divide.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_divide.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_divide, 0, 4, "int32"), "intrp_fused_divide.T_divide.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_divide, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_divide, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_divide, 0, 7, "uint16") == T.uint16(1), "intrp_fused_divide.T_divide.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_divide_T_divide_shape_1[0]) == 1024, "Argument intrp_fused_divide.T_divide.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_divide_T_divide_shape[0])"
    if not T.isnullptr(intrp_fused_divide_T_divide_strides):
        assert 1 == T.Cast("int32", intrp_fused_divide_T_divide_strides_1[0]), "intrp_fused_divide.T_divide.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, "uint64"), "Argument intrp_fused_divide.T_divide.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_divide, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_divide, 0, 10, "int32") == 1, "Argument intrp_fused_divide.T_divide.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_divide, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_divide, 0, 9, "int32"), "Argument intrp_fused_divide.T_divide.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_divide, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_divide_2 = T.decl_buffer((1024,), data=T_divide_1)
    with T.attr(0, "compute_scope", "intrp_fused_divide_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1,), data=p0_1)
            T_divide_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(p0_3[0], 16) / p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_negative(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_negative: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_negative_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_negative: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_negative_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_negative_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_p0_shape)
    intrp_fused_negative_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_negative_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_negative_1: T.handle("float32") = T.tvm_struct_get(T_negative, 0, 1, "handle")
    T.attr(T_negative_1, "storage_alignment", 64)
    intrp_fused_negative_T_negative_shape: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 2, "handle")
    intrp_fused_negative_T_negative_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_negative_T_negative_shape)
    intrp_fused_negative_T_negative_strides: T.handle("int64") = T.tvm_struct_get(T_negative, 0, 3, "handle")
    intrp_fused_negative_T_negative_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_negative_T_negative_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_negative: Expect arg[0] to be pointer"
    assert T_negative_code == 3 or T_negative_code == 13 or T_negative_code == 7 or T_negative_code == 4, "intrp_fused_negative: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_negative.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_p0_shape_1[0]) == 1024, "Argument intrp_fused_negative.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_p0_shape[0])"
    if not T.isnullptr(intrp_fused_negative_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_p0_strides_1[0]), "intrp_fused_negative.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_negative.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_negative.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_negative, 0, 4, "int32"), "intrp_fused_negative.T_negative.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_negative, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_negative, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_negative, 0, 7, "uint16") == T.uint16(1), "intrp_fused_negative.T_negative.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_negative_T_negative_shape_1[0]) == 1024, "Argument intrp_fused_negative.T_negative.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_negative_T_negative_shape[0])"
    if not T.isnullptr(intrp_fused_negative_T_negative_strides):
        assert 1 == T.Cast("int32", intrp_fused_negative_T_negative_strides_1[0]), "intrp_fused_negative.T_negative.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, "uint64"), "Argument intrp_fused_negative.T_negative.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_negative, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_negative, 0, 10, "int32") == 1, "Argument intrp_fused_negative.T_negative.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_negative, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_negative, 0, 9, "int32"), "Argument intrp_fused_negative.T_negative.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_negative, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_negative_2 = T.decl_buffer((1024,), data=T_negative_1)
    with T.attr(0, "compute_scope", "intrp_fused_negative_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_negative_2[cse_var_1:cse_var_1 + 16] = T.Broadcast(T.float32(0), 16) - p0_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024,), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_multiply_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] * p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:45] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_add(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_add: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_add_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_add: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_add_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_add_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p0_shape)
    intrp_fused_add_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_add_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_add_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_add_p1_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_p1_shape)
    intrp_fused_add_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_add_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_p1_strides)
    T_add_1: T.handle("float32") = T.tvm_struct_get(T_add, 0, 1, "handle")
    T.attr(T_add_1, "storage_alignment", 64)
    intrp_fused_add_T_add_shape: T.handle("int64") = T.tvm_struct_get(T_add, 0, 2, "handle")
    intrp_fused_add_T_add_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_add_T_add_shape)
    intrp_fused_add_T_add_strides: T.handle("int64") = T.tvm_struct_get(T_add, 0, 3, "handle")
    intrp_fused_add_T_add_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_add_T_add_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_add: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_add: Expect arg[1] to be pointer"
    assert T_add_code == 3 or T_add_code == 13 or T_add_code == 7 or T_add_code == 4, "intrp_fused_add: Expect arg[2] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_add.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p0_shape_1[0]) == 1024, "Argument intrp_fused_add.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p0_shape[0])"
    if not T.isnullptr(intrp_fused_add_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p0_strides_1[0]), "intrp_fused_add.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_add.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_add.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_add.p1.ndim is expected to equal 1"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_p1_shape_1[0]) == 1024, "Argument intrp_fused_add.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_p1_shape[0])"
    if not T.isnullptr(intrp_fused_add_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_p1_strides_1[0]), "intrp_fused_add.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_add.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_add.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_add.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_add, 0, 4, "int32"), "intrp_fused_add.T_add.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_add, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_add, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_add, 0, 7, "uint16") == T.uint16(1), "intrp_fused_add.T_add.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_add_T_add_shape_1[0]) == 1024, "Argument intrp_fused_add.T_add.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_add_T_add_shape[0])"
    if not T.isnullptr(intrp_fused_add_T_add_strides):
        assert 1 == T.Cast("int32", intrp_fused_add_T_add_strides_1[0]), "intrp_fused_add.T_add.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, "uint64"), "Argument intrp_fused_add.T_add.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_add, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_add, 0, 10, "int32") == 1, "Argument intrp_fused_add.T_add.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_add, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_add, 0, 9, "int32"), "Argument intrp_fused_add.T_add.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_add, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    p1_2 = T.decl_buffer((1024,), data=p1_1)
    T_add_2 = T.decl_buffer((1024,), data=T_add_1)
    with T.attr(0, "compute_scope", "intrp_fused_add_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            T_add_2[cse_var_1:cse_var_1 + 16] = p0_2[cse_var_1:cse_var_1 + 16] + p1_2[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 3"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 32, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 32, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((32,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((32,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 3, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 27 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 27 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 3, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((32, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((32, 3, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(96):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((864,), data=T_multiply_1)
                p0_3 = T.Buffer((864,), data=p0_1)
                p1_3 = T.Buffer((32,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[T.Div(ax0_ax1_fused, 3)], 3)
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 32, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 32, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((32,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(2):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((32,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((32, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 32, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 32, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((32, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((32, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((288,), data=T_multiply_1)
                p0_3 = T.Buffer((288,), data=p0_1)
                p1_3 = T.Buffer((32,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 64, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 64, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((64,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((64,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 32, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 32 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 32, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 32 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 32, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((64, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((64, 32, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(2048):
            T_multiply_3 = T.Buffer((2048,), data=T_multiply_1)
            p0_3 = T.Buffer((2048,), data=p0_1)
            p1_3 = T.Buffer((64,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 5)]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 64, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 64, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((64,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(4):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((64,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((64, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 64, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 64, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((64, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((64, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((576,), data=T_multiply_1)
                p0_3 = T.Buffer((576,), data=p0_1)
                p1_3 = T.Buffer((64,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 128, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 128, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((128,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((128,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:46] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 64, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 64 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 64, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 64 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 64, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((128, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((128, 64, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(8192):
            T_multiply_3 = T.Buffer((8192,), data=T_multiply_1)
            p0_3 = T.Buffer((8192,), data=p0_1)
            p1_3 = T.Buffer((128,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 6)]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 128, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 128, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((128,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((128,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((128, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((128, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((1152,), data=T_multiply_1)
                p0_3 = T.Buffer((1152,), data=p0_1)
                p1_3 = T.Buffer((128,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 128, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 128, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((128,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((128,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 128, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 128 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 128 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 128, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((128, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((128, 128, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(16384):
            T_multiply_3 = T.Buffer((16384,), data=T_multiply_1)
            p0_3 = T.Buffer((16384,), data=p0_1)
            p1_3 = T.Buffer((128,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 7)]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 128, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 128, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((128,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(8):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((128,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((128, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 128, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 128, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((128, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((128, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((1152,), data=T_multiply_1)
                p0_3 = T.Buffer((1152,), data=p0_1)
                p1_3 = T.Buffer((128,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 256, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 256, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((256,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((256,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 128, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 128 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 128, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 128 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 128, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((256, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((256, 128, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(32768):
            T_multiply_3 = T.Buffer((32768,), data=T_multiply_1)
            p0_3 = T.Buffer((32768,), data=p0_1)
            p1_3 = T.Buffer((256,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 7)]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 256, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 256, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((256,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((256,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((256, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((256, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((2304,), data=T_multiply_1)
                p0_3 = T.Buffer((2304,), data=p0_1)
                p1_3 = T.Buffer((256,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 256, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 256, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((256,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((256,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:47] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 256, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 256 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 256 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 256, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((256, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((256, 256, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(65536):
            T_multiply_3 = T.Buffer((65536,), data=T_multiply_1)
            p0_3 = T.Buffer((65536,), data=p0_1)
            p1_3 = T.Buffer((256,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 8)]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 256, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 256, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((256,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(16):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((256,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((256, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 256, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 256, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((256, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((256, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((2304,), data=T_multiply_1)
                p0_3 = T.Buffer((2304,), data=p0_1)
                p1_3 = T.Buffer((256,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 256, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 256 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 256, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 256 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 256, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 256, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(131072):
            T_multiply_3 = T.Buffer((131072,), data=T_multiply_1)
            p0_3 = T.Buffer((131072,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 8)]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(262144):
            T_multiply_3 = T.Buffer((262144,), data=T_multiply_1)
            p0_3 = T.Buffer((262144,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:48] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(262144):
            T_multiply_3 = T.Buffer((262144,), data=T_multiply_1)
            p0_3 = T.Buffer((262144,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(262144):
            T_multiply_3 = T.Buffer((262144,), data=T_multiply_1)
            p0_3 = T.Buffer((262144,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(262144):
            T_multiply_3 = T.Buffer((262144,), data=T_multiply_1)
            p0_3 = T.Buffer((262144,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:49] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(262144):
            T_multiply_3 = T.Buffer((262144,), data=T_multiply_1)
            p0_3 = T.Buffer((262144,), data=p0_1)
            p1_3 = T.Buffer((512,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 512, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 512, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((512,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(32):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((512,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((512, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 512, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 512, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((512, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((512, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((4608,), data=T_multiply_1)
                p0_3 = T.Buffer((4608,), data=p0_1)
                p1_3 = T.Buffer((512,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((1024,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 512, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 512, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 512 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 512, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((1024, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024, 512, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(524288):
            T_multiply_3 = T.Buffer((524288,), data=T_multiply_1)
            p0_3 = T.Buffer((524288,), data=p0_1)
            p1_3 = T.Buffer((1024,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 9)]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((1024,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 3, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 3, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 3, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 3 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[3]) and 3 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[2]) and 9 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 3, 3), data=p0_1)
    p1_2 = T.decl_buffer((1024, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024, 1, 3, 3), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            for ax2 in range(3):
                cse_var_1: T.int32 = ax0_ax1_fused * 9 + ax2 * 3
                T_multiply_3 = T.Buffer((9216,), data=T_multiply_1)
                p0_3 = T.Buffer((9216,), data=p0_1)
                p1_3 = T.Buffer((1024,), data=p1_1)
                T_multiply_3[cse_var_1:cse_var_1 + 3] = p0_3[cse_var_1:cse_var_1 + 3] * T.Broadcast(p1_3[ax0_ax1_fused], 3)
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_squeeze(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_squeeze: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_squeeze_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_squeeze: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_squeeze_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_squeeze_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_squeeze_p0_shape)
    intrp_fused_squeeze_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_squeeze_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_squeeze_1: T.handle("float32") = T.tvm_struct_get(T_squeeze, 0, 1, "handle")
    T.attr(T_squeeze_1, "storage_alignment", 64)
    intrp_fused_squeeze_T_squeeze_shape: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 2, "handle")
    intrp_fused_squeeze_T_squeeze_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_squeeze_T_squeeze_shape)
    intrp_fused_squeeze_T_squeeze_strides: T.handle("int64") = T.tvm_struct_get(T_squeeze, 0, 3, "handle")
    intrp_fused_squeeze_T_squeeze_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_squeeze_T_squeeze_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_squeeze: Expect arg[0] to be pointer"
    assert T_squeeze_code == 3 or T_squeeze_code == 13 or T_squeeze_code == 7 or T_squeeze_code == 4, "intrp_fused_squeeze: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_squeeze.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[1]) == 1, "Argument intrp_fused_squeeze.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_squeeze_p0_shape_1[2]) == 1, "Argument intrp_fused_squeeze.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_squeeze_p0_shape[2])"
    if not T.isnullptr(intrp_fused_squeeze_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_p0_strides_1[0]), "intrp_fused_squeeze.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_squeeze.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(T_squeeze, 0, 4, "int32"), "intrp_fused_squeeze.T_squeeze.ndim is expected to equal 1"
    assert T.tvm_struct_get(T_squeeze, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_squeeze, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_squeeze, 0, 7, "uint16") == T.uint16(1), "intrp_fused_squeeze.T_squeeze.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_squeeze_T_squeeze_shape_1[0]) == 1024, "Argument intrp_fused_squeeze.T_squeeze.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_squeeze_T_squeeze_shape[0])"
    if not T.isnullptr(intrp_fused_squeeze_T_squeeze_strides):
        assert 1 == T.Cast("int32", intrp_fused_squeeze_T_squeeze_strides_1[0]), "intrp_fused_squeeze.T_squeeze.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, "uint64"), "Argument intrp_fused_squeeze.T_squeeze.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_squeeze, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_squeeze, 0, 10, "int32") == 1, "Argument intrp_fused_squeeze.T_squeeze.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_squeeze, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_squeeze, 0, 9, "int32"), "Argument intrp_fused_squeeze.T_squeeze.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_squeeze, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_squeeze_2 = T.decl_buffer((1024,), data=T_squeeze_1)
    with T.attr(0, "compute_scope", "intrp_fused_squeeze_compute_"):
        for ax0_outer in T.parallel(64):
            cse_var_1: T.int32 = ax0_outer * 16
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_squeeze_2[cse_var_1:cse_var_1 + 16] = p0_3[cse_var_1:cse_var_1 + 16]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[0]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1024, 1, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_2[ax0_ax1_fused]
    T.ret(0)
[23:16:50] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_multiply(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 3, "intrp_fused_multiply: num_args should be 3"
    arg_type_ids_1 = T.decl_buffer((3,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    p1_code: T.int32 = arg_type_ids_1[1]
    T_multiply_code: T.int32 = arg_type_ids_1[2]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    p1: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    T_multiply: T.handle = T.tvm_struct_get(args, 2, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_multiply_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_multiply_p0_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p0_shape)
    intrp_fused_multiply_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_multiply_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    p1_1: T.handle("float32") = T.tvm_struct_get(p1, 0, 1, "handle")
    T.attr(p1_1, "storage_alignment", 64)
    intrp_fused_multiply_p1_shape: T.handle("int64") = T.tvm_struct_get(p1, 0, 2, "handle")
    intrp_fused_multiply_p1_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_p1_shape)
    intrp_fused_multiply_p1_strides: T.handle("int64") = T.tvm_struct_get(p1, 0, 3, "handle")
    intrp_fused_multiply_p1_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_p1_strides)
    T_multiply_1: T.handle("float32") = T.tvm_struct_get(T_multiply, 0, 1, "handle")
    T.attr(T_multiply_1, "storage_alignment", 64)
    intrp_fused_multiply_T_multiply_shape: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 2, "handle")
    intrp_fused_multiply_T_multiply_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_multiply_T_multiply_shape)
    intrp_fused_multiply_T_multiply_strides: T.handle("int64") = T.tvm_struct_get(T_multiply, 0, 3, "handle")
    intrp_fused_multiply_T_multiply_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_multiply_T_multiply_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_multiply: Expect arg[0] to be pointer"
    assert p1_code == 3 or p1_code == 13 or p1_code == 7 or p1_code == 4, "intrp_fused_multiply: Expect arg[1] to be pointer"
    assert T_multiply_code == 3 or T_multiply_code == 13 or T_multiply_code == 7 or T_multiply_code == 4, "intrp_fused_multiply: Expect arg[2] to be pointer"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_multiply.p0.ndim is expected to equal 4"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[1]) == 1024, "Argument intrp_fused_multiply.p0.shape[1] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[2]) == 1, "Argument intrp_fused_multiply.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p0_shape_1[3]) == 1, "Argument intrp_fused_multiply.p0.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p0_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[1]) and 1024 == T.Cast("int32", intrp_fused_multiply_p0_strides_1[0]), "intrp_fused_multiply.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_multiply.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(p1, 0, 4, "int32"), "intrp_fused_multiply.p1.ndim is expected to equal 4"
    assert T.tvm_struct_get(p1, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p1, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p1, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.p1.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[0]) == 1024, "Argument intrp_fused_multiply.p1.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[1]) == 1, "Argument intrp_fused_multiply.p1.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[2]) == 1, "Argument intrp_fused_multiply.p1.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_p1_shape_1[3]) == 1, "Argument intrp_fused_multiply.p1.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_p1_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_p1_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_p1_strides_1[0]), "intrp_fused_multiply.p1.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p1, 0, 8, "uint64"), "Argument intrp_fused_multiply.p1.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p1, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p1, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.p1.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p1, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(p1, 0, 9, "int32"), "Argument intrp_fused_multiply.p1.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(p1, 0, 9, \"int32\")"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_multiply, 0, 4, "int32"), "intrp_fused_multiply.T_multiply.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_multiply, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_multiply, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_multiply, 0, 7, "uint16") == T.uint16(1), "intrp_fused_multiply.T_multiply.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[0]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[0])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[1]) == 1024, "Argument intrp_fused_multiply.T_multiply.shape[1] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[1])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[2]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[2])"
    assert T.Cast("int32", intrp_fused_multiply_T_multiply_shape_1[3]) == 1, "Argument intrp_fused_multiply.T_multiply.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_multiply_T_multiply_shape[3])"
    if not T.isnullptr(intrp_fused_multiply_T_multiply_strides):
        assert 1 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[1]) and 1024 == T.Cast("int32", intrp_fused_multiply_T_multiply_strides_1[0]), "intrp_fused_multiply.T_multiply.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, "uint64"), "Argument intrp_fused_multiply.T_multiply.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_multiply, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_multiply, 0, 10, "int32") == 1, "Argument intrp_fused_multiply.T_multiply.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_multiply, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_multiply, 0, 9, "int32"), "Argument intrp_fused_multiply.T_multiply.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_multiply, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1024, 1, 1), data=p0_1)
    p1_2 = T.decl_buffer((1024, 1, 1, 1), data=p1_1)
    T_multiply_2 = T.decl_buffer((1024, 1024, 1, 1), data=T_multiply_1)
    with T.attr(0, "compute_scope", "intrp_fused_multiply_compute_"):
        for ax0_ax1_fused in T.parallel(1048576):
            T_multiply_3 = T.Buffer((1048576,), data=T_multiply_1)
            p0_3 = T.Buffer((1048576,), data=p0_1)
            p1_3 = T.Buffer((1024,), data=p1_1)
            T_multiply_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused] * p1_3[T.shift_right(ax0_ax1_fused, 10)]
    T.ret(0)
[23:16:52] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            p0_3 = T.Buffer((32,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:52] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 32, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 32, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 32 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((32, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 32, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(32):
            T_expand_dims_3 = T.Buffer((32,), data=T_expand_dims_1)
            p0_3 = T.Buffer((32,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:52] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            p0_3 = T.Buffer((64,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:52] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 64, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 64, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 64 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((64, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 64, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(64):
            T_expand_dims_3 = T.Buffer((64,), data=T_expand_dims_1)
            p0_3 = T.Buffer((64,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            p0_3 = T.Buffer((128,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            p0_3 = T.Buffer((128,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            p0_3 = T.Buffer((128,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 128, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 128, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 128 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((128, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 128, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(128):
            T_expand_dims_3 = T.Buffer((128,), data=T_expand_dims_1)
            p0_3 = T.Buffer((128,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            p0_3 = T.Buffer((256,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            p0_3 = T.Buffer((256,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            p0_3 = T.Buffer((256,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 256, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 256, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 256 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((256, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 256, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(256):
            T_expand_dims_3 = T.Buffer((256,), data=T_expand_dims_1)
            p0_3 = T.Buffer((256,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:53] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 512, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 512, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 512 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((512, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 512, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(512):
            T_expand_dims_3 = T.Buffer((512,), data=T_expand_dims_1)
            p0_3 = T.Buffer((512,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((3,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((4,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert 3 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 3"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1024, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[1]) == 1, "Argument intrp_fused_expand_dims.p0.shape[1] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.p0.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[2])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert 4 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 4"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1024, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1024 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[2]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[2] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[2])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[3]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[3] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[3])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1024, 1, 1), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 1024, 1, 1), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax0_ax1_fused in T.parallel(1024):
            T_expand_dims_3 = T.Buffer((1024,), data=T_expand_dims_1)
            p0_3 = T.Buffer((1024,), data=p0_1)
            T_expand_dims_3[ax0_ax1_fused] = p0_3[ax0_ax1_fused]
    T.ret(0)
[23:16:54] /src/tvm/src/target/llvm/codegen_llvm.cc:234: Adding PrimFunc CPU:
# from tvm.script import tir as T

@T.prim_func
def intrp_fused_expand_dims(args: T.handle, arg_type_ids: T.handle("int32"), num_args: T.int32, out_ret_value: T.handle("void"), out_ret_tcode: T.handle("int32"), resource_handle: T.handle) -> T.int32:
    T.func_attr({"calling_conv": 1, "from_legacy_te_schedule": T.bool(True), "target": T.target({"keys": ["cpu"], "kind": "llvm", "tag": ""}), "tir.is_entry_func": T.bool(True), "tir.noalias": T.bool(True)})
    assert num_args == 2, "intrp_fused_expand_dims: num_args should be 2"
    arg_type_ids_1 = T.decl_buffer((2,), "int32", data=arg_type_ids)
    p0_code: T.int32 = arg_type_ids_1[0]
    T_expand_dims_code: T.int32 = arg_type_ids_1[1]
    p0: T.handle = T.tvm_struct_get(args, 0, 12, "handle")
    T_expand_dims: T.handle = T.tvm_struct_get(args, 1, 12, "handle")
    p0_1: T.handle("float32") = T.tvm_struct_get(p0, 0, 1, "handle")
    T.attr(p0_1, "storage_alignment", 64)
    intrp_fused_expand_dims_p0_shape: T.handle("int64") = T.tvm_struct_get(p0, 0, 2, "handle")
    intrp_fused_expand_dims_p0_shape_1 = T.decl_buffer((1,), "int64", data=intrp_fused_expand_dims_p0_shape)
    intrp_fused_expand_dims_p0_strides: T.handle("int64") = T.tvm_struct_get(p0, 0, 3, "handle")
    intrp_fused_expand_dims_p0_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_p0_strides)
    dev_id: T.int32 = T.tvm_struct_get(p0, 0, 9, "int32")
    T_expand_dims_1: T.handle("float32") = T.tvm_struct_get(T_expand_dims, 0, 1, "handle")
    T.attr(T_expand_dims_1, "storage_alignment", 64)
    intrp_fused_expand_dims_T_expand_dims_shape: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 2, "handle")
    intrp_fused_expand_dims_T_expand_dims_shape_1 = T.decl_buffer((2,), "int64", data=intrp_fused_expand_dims_T_expand_dims_shape)
    intrp_fused_expand_dims_T_expand_dims_strides: T.handle("int64") = T.tvm_struct_get(T_expand_dims, 0, 3, "handle")
    intrp_fused_expand_dims_T_expand_dims_strides_1 = T.decl_buffer((0,), "int64", data=intrp_fused_expand_dims_T_expand_dims_strides)
    assert p0_code == 3 or p0_code == 13 or p0_code == 7 or p0_code == 4, "intrp_fused_expand_dims: Expect arg[0] to be pointer"
    assert T_expand_dims_code == 3 or T_expand_dims_code == 13 or T_expand_dims_code == 7 or T_expand_dims_code == 4, "intrp_fused_expand_dims: Expect arg[1] to be pointer"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert 1 == T.tvm_struct_get(p0, 0, 4, "int32"), "intrp_fused_expand_dims.p0.ndim is expected to equal 1"
    assert T.tvm_struct_get(p0, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(p0, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(p0, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.p0.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_p0_shape_1[0]) == 1000, "Argument intrp_fused_expand_dims.p0.shape[0] has an unsatisfied constraint: 1000 == T.Cast(\"int32\", intrp_fused_expand_dims_p0_shape[0])"
    if not T.isnullptr(intrp_fused_expand_dims_p0_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_p0_strides_1[0]), "intrp_fused_expand_dims.p0.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(p0, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.p0.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(p0, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(p0, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.p0.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(p0, 0, 10, \"int32\")"
    assert 2 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 2"
    assert 2 == T.tvm_struct_get(T_expand_dims, 0, 4, "int32"), "intrp_fused_expand_dims.T_expand_dims.ndim is expected to equal 2"
    assert T.tvm_struct_get(T_expand_dims, 0, 5, "uint8") == T.uint8(2) and T.tvm_struct_get(T_expand_dims, 0, 6, "uint8") == T.uint8(32) and T.tvm_struct_get(T_expand_dims, 0, 7, "uint16") == T.uint16(1), "intrp_fused_expand_dims.T_expand_dims.dtype is expected to be float32"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[0]) == 1, "Argument intrp_fused_expand_dims.T_expand_dims.shape[0] has an unsatisfied constraint: 1 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[0])"
    assert T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_shape_1[1]) == 1000, "Argument intrp_fused_expand_dims.T_expand_dims.shape[1] has an unsatisfied constraint: 1000 == T.Cast(\"int32\", intrp_fused_expand_dims_T_expand_dims_shape[1])"
    if not T.isnullptr(intrp_fused_expand_dims_T_expand_dims_strides):
        assert 1 == T.Cast("int32", intrp_fused_expand_dims_T_expand_dims_strides_1[1]), "intrp_fused_expand_dims.T_expand_dims.strides: expected to be compact array"
        T.evaluate(0)
    assert T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, "uint64"), "Argument intrp_fused_expand_dims.T_expand_dims.byte_offset has an unsatisfied constraint: T.uint64(0) == T.tvm_struct_get(T_expand_dims, 0, 8, \"uint64\")"
    assert T.tvm_struct_get(T_expand_dims, 0, 10, "int32") == 1, "Argument intrp_fused_expand_dims.T_expand_dims.device_type has an unsatisfied constraint: 1 == T.tvm_struct_get(T_expand_dims, 0, 10, \"int32\")"
    assert dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, "int32"), "Argument intrp_fused_expand_dims.T_expand_dims.device_id has an unsatisfied constraint: dev_id == T.tvm_struct_get(T_expand_dims, 0, 9, \"int32\")"
    p0_2 = T.decl_buffer((1000,), data=p0_1)
    T_expand_dims_2 = T.decl_buffer((1, 1000), data=T_expand_dims_1)
    with T.attr(0, "compute_scope", "intrp_fused_expand_dims_compute_"):
        for ax1_outer, ax1_inner_s in T.grid(63, 16):
            if ax1_outer * 2 + T.shift_right(ax1_inner_s, 3) < 125:
                T_expand_dims_3 = T.Buffer((1000,), data=T_expand_dims_1)
                cse_var_1: T.int32 = ax1_outer * 16 + ax1_inner_s
                T_expand_dims_3[cse_var_1] = p0_2[cse_var_1]
    T.ret(0)
One or more operators have not been tuned. Please tune your model for better performance. Use DEBUG logging level to see more details.
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_batch_flatten_kernel(p0: T.handle("float32"), tensor: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.x", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p0_1 = T.decl_buffer((1024,), data=p0)
    tensor_1 = T.decl_buffer((1024,), data=tensor)
    blockIdx_x = T.launch_thread("blockIdx.x", 4)
    threadIdx_x = T.launch_thread("threadIdx.x", 256)
    tensor_1[blockIdx_x * 256 + threadIdx_x] = p0_1[blockIdx_x * 256 + threadIdx_x]
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_10_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((256,), data=p2)
    T_relu_1 = T.decl_buffer((200704,), data=T_relu)
    p1_1 = T.decl_buffer((65536,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((256,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((200704,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((896,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 8)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([896], "float32", "shared")
    p1_shared = T.allocate([256], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 7)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 4)
    threadIdx_x = T.launch_thread("threadIdx.x", 4)
    for ff_init, xx_init in T.grid(4, 7):
        conv2d_nchw_1[ff_init * 7 + xx_init] = T.float32(0)
    for rc_outer in range(32):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in range(7):
                pad_temp_shared_1[threadIdx_z_1 * 112 + threadIdx_y_1 * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p0_1[rc_outer * 6272 + threadIdx_z_1 * 784 + blockIdx_y * 112 + threadIdx_y_1 * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in range(2):
                p1_shared_1[threadIdx_z_1 * 32 + threadIdx_y_1 * 8 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + threadIdx_y_1 * 256 + rc_outer * 8 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        T.tvm_storage_sync("shared")
        for rc_inner, ff, xx in T.grid(8, 4, 7):
            conv2d_nchw_1[ff * 7 + xx] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 28 + threadIdx_x * 7 + xx], p1_shared_1[threadIdx_z * 32 + ff * 8 + rc_inner], conv2d_nchw_1[ff * 7 + xx])
    for ax1_inner_inner_inner, ax3_inner_inner_inner in T.grid(4, 7):
        T_relu_1[blockIdx_z * 25088 + threadIdx_z * 3136 + ax1_inner_inner_inner * 784 + blockIdx_y * 112 + threadIdx_y * 28 + threadIdx_x * 7 + ax3_inner_inner_inner] = T.max(conv2d_nchw_1[ax1_inner_inner_inner * 7 + ax3_inner_inner_inner] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + ax1_inner_inner_inner], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_11_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((256,), data=p2)
    T_relu_1 = T.decl_buffer((50176,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((2,), data=DepthwiseConv2d, scope="local", align=8)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((15,), data=PaddedInput_shared_local, scope="local", align=32)
    p1_1 = T.decl_buffer((2304,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((200704,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((435,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 256)
    PaddedInput_shared = T.allocate([435], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([15], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([2], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 2)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    for ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer in range(9):
        threadIdx_z = T.launch_thread("threadIdx.z", 1)
        threadIdx_y = T.launch_thread("threadIdx.y", 7)
        threadIdx_x = T.launch_thread("threadIdx.x", 7)
        if ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x < 435:
            PaddedInput_shared_1[ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x] = T.if_then_else(1 <= blockIdx_y * 14 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 29) and 1 <= T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 29), p0_1[blockIdx_z * 784 + blockIdx_y * 392 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 29) * 28 + T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 29) - 29], T.float32(0))
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        threadIdx_y = T.launch_thread("threadIdx.y", 7)
        threadIdx_x = T.launch_thread("threadIdx.x", 7)
        if threadIdx_y * 7 + threadIdx_x < 9:
            if threadIdx_y < 2:
                p1_shared_1[threadIdx_y * 7 + threadIdx_x] = p1_1[blockIdx_z * 9 + threadIdx_y * 7 + threadIdx_x]
    threadIdx_z = T.launch_thread("threadIdx.z", 1)
    threadIdx_y = T.launch_thread("threadIdx.y", 7)
    threadIdx_x = T.launch_thread("threadIdx.x", 7)
    T.tvm_storage_sync("shared")
    for ax2, ax3 in T.grid(3, 5):
        PaddedInput_shared_local_1[ax2 * 5 + ax3] = PaddedInput_shared_1[threadIdx_y * 58 + ax2 * 29 + threadIdx_x * 4 + ax3]
    for ax2, ax3 in T.grid(3, 3):
        p1_shared_local_1[ax2 * 3 + ax3] = p1_shared_1[ax2 * 3 + ax3]
    for j in range(2):
        DepthwiseConv2d_1[j] = T.float32(0)
        for di, dj in T.grid(3, 3):
            DepthwiseConv2d_1[j] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[di * 5 + j * 2 + dj], p1_shared_local_1[di * 3 + dj], DepthwiseConv2d_1[j])
    for ax3_inner_inner_inner in range(2):
        T_relu_1[blockIdx_z * 196 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 2 + ax3_inner_inner_inner] = T.max(DepthwiseConv2d_1[ax3_inner_inner_inner] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_12_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((512,), data=p2)
    T_relu_1 = T.decl_buffer((100352,), data=T_relu)
    p1_1 = T.decl_buffer((131072,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((512,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((50176,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((1568,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 16)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([1568], "float32", "shared")
    p1_shared = T.allocate([512], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 2)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 7)
    threadIdx_x = T.launch_thread("threadIdx.x", 2)
    conv2d_nchw_1[0] = T.float32(0)
    conv2d_nchw_1[1] = T.float32(0)
    conv2d_nchw_1[2] = T.float32(0)
    conv2d_nchw_1[3] = T.float32(0)
    conv2d_nchw_1[4] = T.float32(0)
    conv2d_nchw_1[5] = T.float32(0)
    conv2d_nchw_1[6] = T.float32(0)
    conv2d_nchw_1[7] = T.float32(0)
    conv2d_nchw_1[8] = T.float32(0)
    conv2d_nchw_1[9] = T.float32(0)
    conv2d_nchw_1[10] = T.float32(0)
    conv2d_nchw_1[11] = T.float32(0)
    conv2d_nchw_1[12] = T.float32(0)
    conv2d_nchw_1[13] = T.float32(0)
    conv2d_nchw_1[14] = T.float32(0)
    conv2d_nchw_1[15] = T.float32(0)
    conv2d_nchw_1[16] = T.float32(0)
    conv2d_nchw_1[17] = T.float32(0)
    conv2d_nchw_1[18] = T.float32(0)
    conv2d_nchw_1[19] = T.float32(0)
    conv2d_nchw_1[20] = T.float32(0)
    conv2d_nchw_1[21] = T.float32(0)
    conv2d_nchw_1[22] = T.float32(0)
    conv2d_nchw_1[23] = T.float32(0)
    conv2d_nchw_1[24] = T.float32(0)
    conv2d_nchw_1[25] = T.float32(0)
    conv2d_nchw_1[26] = T.float32(0)
    conv2d_nchw_1[27] = T.float32(0)
    for rc_outer in range(16):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 2)
            T.tvm_storage_sync("shared")
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 1] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 2] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 3] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 4] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 5] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 6] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 7] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 7]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 8] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 8]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 9] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 9]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 10] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 10]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 11] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 11]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 12] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 12]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 13] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 13]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 2)
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 512:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2, 3) * 256 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1), 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 511:
                    if threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1) < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 1] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1), 3) * 256 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 1, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 1, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 510:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 31:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 2] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 1, 3) * 256 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 2, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1), 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 509:
                    if threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1) < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 3] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1), 3) * 256 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 3, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 2, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 508:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 30:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 4] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 2, 3) * 256 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 4, 15)]
        T.tvm_storage_sync("shared")
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[27])
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7] = T.max(conv2d_nchw_1[0] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 1] = T.max(conv2d_nchw_1[1] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 2] = T.max(conv2d_nchw_1[2] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 3] = T.max(conv2d_nchw_1[3] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 4] = T.max(conv2d_nchw_1[4] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 5] = T.max(conv2d_nchw_1[5] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 6] = T.max(conv2d_nchw_1[6] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 196] = T.max(conv2d_nchw_1[7] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 197] = T.max(conv2d_nchw_1[8] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 198] = T.max(conv2d_nchw_1[9] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 199] = T.max(conv2d_nchw_1[10] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 200] = T.max(conv2d_nchw_1[11] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 201] = T.max(conv2d_nchw_1[12] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 202] = T.max(conv2d_nchw_1[13] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 392] = T.max(conv2d_nchw_1[14] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 393] = T.max(conv2d_nchw_1[15] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 394] = T.max(conv2d_nchw_1[16] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 395] = T.max(conv2d_nchw_1[17] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 396] = T.max(conv2d_nchw_1[18] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 397] = T.max(conv2d_nchw_1[19] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 398] = T.max(conv2d_nchw_1[20] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 588] = T.max(conv2d_nchw_1[21] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 589] = T.max(conv2d_nchw_1[22] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 590] = T.max(conv2d_nchw_1[23] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 591] = T.max(conv2d_nchw_1[24] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 592] = T.max(conv2d_nchw_1[25] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 593] = T.max(conv2d_nchw_1[26] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 594] = T.max(conv2d_nchw_1[27] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_13_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((512,), data=p2)
    T_relu_1 = T.decl_buffer((100352,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((4,), data=DepthwiseConv2d, scope="local", align=16)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((16,), data=PaddedInput_shared_local, scope="local")
    p1_1 = T.decl_buffer((4608,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((100352,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((256,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 512)
    PaddedInput_shared = T.allocate([256], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([16], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([4], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x] = T.if_then_else(16 <= threadIdx_y * 7 + threadIdx_x and 1 <= T.bitwise_and(threadIdx_y * 7 + threadIdx_x, 15) and T.bitwise_and(threadIdx_y * 7 + threadIdx_x, 15) < 15, p0_1[blockIdx_z * 196 + T.shift_right(threadIdx_y * 7 + threadIdx_x, 4) * 14 + T.bitwise_and(threadIdx_y * 7 + threadIdx_x, 15) - 15], T.float32(0))
    threadIdx_z = T.env_thread("threadIdx.z")
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x + 49] = T.if_then_else(1 <= T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 1, 15) and T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 1, 15) < 15, p0_1[blockIdx_z * 196 + T.shift_right(threadIdx_y * 7 + threadIdx_x + 49, 4) * 14 + T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 1, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x + 98] = T.if_then_else(1 <= T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 2, 15) and T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 2, 15) < 15, p0_1[blockIdx_z * 196 + T.shift_right(threadIdx_y * 7 + threadIdx_x + 98, 4) * 14 + T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 2, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x + 147] = T.if_then_else(1 <= T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 3, 15) and T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 3, 15) < 15, p0_1[blockIdx_z * 196 + T.shift_right(threadIdx_y * 7 + threadIdx_x + 147, 4) * 14 + T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 3, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x + 196] = T.if_then_else(threadIdx_y * 7 + threadIdx_x < 44 and 1 <= T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 4, 15) and T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 4, 15) < 15, p0_1[blockIdx_z * 196 + T.shift_right(threadIdx_y * 7 + threadIdx_x + 196, 4) * 14 + T.bitwise_and(threadIdx_y * 7 + threadIdx_x + 4, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        if threadIdx_y * 7 + threadIdx_x < 11:
            if threadIdx_y < 2:
                PaddedInput_shared_1[threadIdx_y * 7 + threadIdx_x + 245] = T.float32(0)
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
        if threadIdx_y_1 * 7 + threadIdx_x_1 < 9:
            if threadIdx_y_1 < 2:
                p1_shared_1[threadIdx_y_1 * 7 + threadIdx_x_1] = p1_1[blockIdx_z * 9 + threadIdx_y_1 * 7 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 1)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 3]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 16]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 17]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 18]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 19]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 32]
    PaddedInput_shared_local_1[9] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 33]
    PaddedInput_shared_local_1[10] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 34]
    PaddedInput_shared_local_1[11] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 35]
    PaddedInput_shared_local_1[12] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 48]
    PaddedInput_shared_local_1[13] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 49]
    PaddedInput_shared_local_1[14] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 50]
    PaddedInput_shared_local_1[15] = PaddedInput_shared_1[threadIdx_y_1 * 32 + threadIdx_x_1 * 2 + 51]
    p1_shared_local_1[0] = p1_shared_1[0]
    p1_shared_local_1[1] = p1_shared_1[1]
    p1_shared_local_1[2] = p1_shared_1[2]
    p1_shared_local_1[3] = p1_shared_1[3]
    p1_shared_local_1[4] = p1_shared_1[4]
    p1_shared_local_1[5] = p1_shared_1[5]
    p1_shared_local_1[6] = p1_shared_1[6]
    p1_shared_local_1[7] = p1_shared_1[7]
    p1_shared_local_1[8] = p1_shared_1[8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[1] = T.float32(0)
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[0], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[1], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[2], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[3], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[4], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[5], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[6], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[7], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[8], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[2] = T.float32(0)
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[0], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[1], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[2], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[3], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[4], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[5], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[6], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[7], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[8], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[3] = T.float32(0)
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[0], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[1], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[2], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[3], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[4], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[5], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[6], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[7], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[15], p1_shared_local_1[8], DepthwiseConv2d_1[3])
    T_relu_1[blockIdx_z * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 2] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 2 + 1] = T.max(DepthwiseConv2d_1[1] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 2 + 14] = T.max(DepthwiseConv2d_1[2] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 2 + 15] = T.max(DepthwiseConv2d_1[3] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_14_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((512,), data=p2)
    T_relu_1 = T.decl_buffer((100352,), data=T_relu)
    p1_1 = T.decl_buffer((262144,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((512,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((100352,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((1568,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 16)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([1568], "float32", "shared")
    p1_shared = T.allocate([512], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 2)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 7)
    threadIdx_x = T.launch_thread("threadIdx.x", 2)
    conv2d_nchw_1[0] = T.float32(0)
    conv2d_nchw_1[1] = T.float32(0)
    conv2d_nchw_1[2] = T.float32(0)
    conv2d_nchw_1[3] = T.float32(0)
    conv2d_nchw_1[4] = T.float32(0)
    conv2d_nchw_1[5] = T.float32(0)
    conv2d_nchw_1[6] = T.float32(0)
    conv2d_nchw_1[7] = T.float32(0)
    conv2d_nchw_1[8] = T.float32(0)
    conv2d_nchw_1[9] = T.float32(0)
    conv2d_nchw_1[10] = T.float32(0)
    conv2d_nchw_1[11] = T.float32(0)
    conv2d_nchw_1[12] = T.float32(0)
    conv2d_nchw_1[13] = T.float32(0)
    conv2d_nchw_1[14] = T.float32(0)
    conv2d_nchw_1[15] = T.float32(0)
    conv2d_nchw_1[16] = T.float32(0)
    conv2d_nchw_1[17] = T.float32(0)
    conv2d_nchw_1[18] = T.float32(0)
    conv2d_nchw_1[19] = T.float32(0)
    conv2d_nchw_1[20] = T.float32(0)
    conv2d_nchw_1[21] = T.float32(0)
    conv2d_nchw_1[22] = T.float32(0)
    conv2d_nchw_1[23] = T.float32(0)
    conv2d_nchw_1[24] = T.float32(0)
    conv2d_nchw_1[25] = T.float32(0)
    conv2d_nchw_1[26] = T.float32(0)
    conv2d_nchw_1[27] = T.float32(0)
    for rc_outer in range(32):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 2)
            T.tvm_storage_sync("shared")
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 1] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 2] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 3] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 4] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 5] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 6] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 7] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 7]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 8] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 8]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 9] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 9]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 10] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 10]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 11] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 11]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 12] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 12]
            pad_temp_shared_1[threadIdx_z_1 * 196 + threadIdx_y_1 * 28 + threadIdx_x_1 * 14 + 13] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 196 + blockIdx_y * 98 + T.truncmod(threadIdx_y_1 * 2 + threadIdx_x_1, 7) * 14 + 13]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 2)
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 512:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5] = p1_1[blockIdx_z * 16384 + threadIdx_z_1 * 2048 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2, 3) * 512 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1), 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 511:
                    if threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1) < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 1] = p1_1[blockIdx_z * 16384 + threadIdx_z_1 * 2048 + T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 1, 1), 3) * 512 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 1, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 1, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 510:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 31:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 2] = p1_1[blockIdx_z * 16384 + threadIdx_z_1 * 2048 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 1, 3) * 512 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 2, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1), 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 509:
                    if threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1) < 32:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 3] = p1_1[blockIdx_z * 16384 + threadIdx_z_1 * 2048 + T.shift_right(threadIdx_y_1 * 5 + T.shift_right(threadIdx_x_1 * 5 + 3, 1), 3) * 512 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 3, 15)]
            if T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 2, 5) + threadIdx_z_1 < 8:
                if threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 < 508:
                    if threadIdx_y_1 * 5 + threadIdx_x_1 * 2 < 30:
                        p1_shared_1[threadIdx_z_1 * 64 + threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 4] = p1_1[blockIdx_z * 16384 + threadIdx_z_1 * 2048 + T.shift_right(threadIdx_y_1 * 5 + threadIdx_x_1 * 2 + 2, 3) * 512 + rc_outer * 16 + T.bitwise_and(threadIdx_y_1 * 10 + threadIdx_x_1 * 5 + 4, 15)]
        T.tvm_storage_sync("shared")
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 16], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 32], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 2], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 3], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 4], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 5], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 6], p1_shared_1[threadIdx_z * 64 + 48], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 1], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 17], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 33], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 98], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 99], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 100], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 101], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 102], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 103], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 104], p1_shared_1[threadIdx_z * 64 + 49], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 2], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 18], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 34], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 196], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 197], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 198], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 199], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 200], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 201], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 202], p1_shared_1[threadIdx_z * 64 + 50], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 3], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 19], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 35], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 294], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 295], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 296], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 297], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 298], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 299], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 300], p1_shared_1[threadIdx_z * 64 + 51], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 4], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 20], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 36], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 392], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 393], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 394], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 395], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 396], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 397], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 398], p1_shared_1[threadIdx_z * 64 + 52], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 5], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 21], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 37], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 490], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 491], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 492], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 493], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 494], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 495], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 496], p1_shared_1[threadIdx_z * 64 + 53], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 6], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 22], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 38], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 588], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 589], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 590], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 591], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 592], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 593], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 594], p1_shared_1[threadIdx_z * 64 + 54], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 7], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 23], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 39], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 686], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 687], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 688], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 689], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 690], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 691], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 692], p1_shared_1[threadIdx_z * 64 + 55], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 8], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 24], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 40], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 784], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 785], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 786], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 787], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 788], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 789], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 790], p1_shared_1[threadIdx_z * 64 + 56], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 9], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 25], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 41], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 882], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 883], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 884], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 885], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 886], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 887], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 888], p1_shared_1[threadIdx_z * 64 + 57], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 10], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 26], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 42], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 980], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 981], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 982], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 983], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 984], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 985], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 986], p1_shared_1[threadIdx_z * 64 + 58], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 11], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 27], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 43], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1078], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1079], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1080], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1081], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1082], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1083], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1084], p1_shared_1[threadIdx_z * 64 + 59], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 12], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 28], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 44], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1176], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1177], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1178], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1179], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1180], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1181], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1182], p1_shared_1[threadIdx_z * 64 + 60], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 13], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 29], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 45], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1274], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1275], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1276], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1277], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1278], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1279], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1280], p1_shared_1[threadIdx_z * 64 + 61], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 14], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 30], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 46], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1372], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1373], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1374], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1375], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1376], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1377], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1378], p1_shared_1[threadIdx_z * 64 + 62], conv2d_nchw_1[27])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[0])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[1])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[2])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[3])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[4])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[5])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 15], conv2d_nchw_1[6])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[7])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[8])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[9])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[10])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[11])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[12])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 31], conv2d_nchw_1[13])
        conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[14])
        conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[15])
        conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[16])
        conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[17])
        conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[18])
        conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[19])
        conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 47], conv2d_nchw_1[20])
        conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1470], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[21])
        conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1471], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[22])
        conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1472], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[23])
        conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1473], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[24])
        conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1474], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[25])
        conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1475], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[26])
        conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 14 + threadIdx_x * 7 + 1476], p1_shared_1[threadIdx_z * 64 + 63], conv2d_nchw_1[27])
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7] = T.max(conv2d_nchw_1[0] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 1] = T.max(conv2d_nchw_1[1] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 2] = T.max(conv2d_nchw_1[2] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 3] = T.max(conv2d_nchw_1[3] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 4] = T.max(conv2d_nchw_1[4] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 5] = T.max(conv2d_nchw_1[5] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 6] = T.max(conv2d_nchw_1[6] + p2_1[blockIdx_z * 32 + threadIdx_z * 4], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 196] = T.max(conv2d_nchw_1[7] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 197] = T.max(conv2d_nchw_1[8] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 198] = T.max(conv2d_nchw_1[9] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 199] = T.max(conv2d_nchw_1[10] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 200] = T.max(conv2d_nchw_1[11] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 201] = T.max(conv2d_nchw_1[12] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 202] = T.max(conv2d_nchw_1[13] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 1], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 392] = T.max(conv2d_nchw_1[14] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 393] = T.max(conv2d_nchw_1[15] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 394] = T.max(conv2d_nchw_1[16] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 395] = T.max(conv2d_nchw_1[17] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 396] = T.max(conv2d_nchw_1[18] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 397] = T.max(conv2d_nchw_1[19] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 398] = T.max(conv2d_nchw_1[20] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 2], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 588] = T.max(conv2d_nchw_1[21] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 589] = T.max(conv2d_nchw_1[22] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 590] = T.max(conv2d_nchw_1[23] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 591] = T.max(conv2d_nchw_1[24] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 592] = T.max(conv2d_nchw_1[25] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 593] = T.max(conv2d_nchw_1[26] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
    T_relu_1[blockIdx_z * 6272 + threadIdx_z * 784 + blockIdx_y * 98 + threadIdx_y * 14 + threadIdx_x * 7 + 594] = T.max(conv2d_nchw_1[27] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + 3], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_15_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((512,), data=p2)
    T_relu_1 = T.decl_buffer((25088,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((1,), data=DepthwiseConv2d, scope="local", align=4)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((9,), data=PaddedInput_shared_local, scope="local", align=32)
    p1_1 = T.decl_buffer((4608,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((72,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((100352,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((1800,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 64)
    PaddedInput_shared = T.allocate([1800], "float32", "shared")
    p1_shared = T.allocate([72], "float32", "shared")
    PaddedInput_shared_local = T.allocate([9], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([1], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.env_thread("threadIdx.z")
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread(threadIdx_z, 8):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x] = T.if_then_else(15 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x, 225) and 1 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x, 15), p0_1[blockIdx_z * 1568 + T.Div(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x, 225) * 196 + T.Div(T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x, 225), 15) * 14 + T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 8):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 392] = T.if_then_else(15 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 167, 225) and 1 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 2, 15), p0_1[blockIdx_z * 1568 + T.Div(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 392, 225) * 196 + T.Div(T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 167, 225), 15) * 14 + T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 2, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 8):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 784] = T.if_then_else(15 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 109, 225) and 1 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 4, 15), p0_1[blockIdx_z * 1568 + T.Div(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 784, 225) * 196 + T.Div(T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 109, 225), 15) * 14 + T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 4, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 8):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        PaddedInput_shared_1[threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 1176] = T.if_then_else(15 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 51, 225) and 1 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 6, 15), p0_1[blockIdx_z * 1568 + T.Div(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 1176, 225) * 196 + T.Div(T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 51, 225), 15) * 14 + T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 6, 15) - 15], T.float32(0))
    with T.launch_thread(threadIdx_z, 8):
        T.launch_thread(threadIdx_y, 7)
        T.launch_thread(threadIdx_x, 7)
        if threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x < 232:
            if threadIdx_z * 7 + threadIdx_y < 34:
                if threadIdx_z < 5:
                    PaddedInput_shared_1[threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 1568] = T.if_then_else(15 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 218, 225) and 1 <= T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 8, 15), p0_1[blockIdx_z * 1568 + T.Div(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 1568, 225) * 196 + T.Div(T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 218, 225), 15) * 14 + T.truncmod(threadIdx_z * 49 + threadIdx_y * 7 + threadIdx_x + 8, 15) - 15], T.float32(0))
    with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
        if threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + threadIdx_x_1 < 72:
            if threadIdx_z_1 * 7 + threadIdx_y_1 < 11:
                if threadIdx_z_1 < 2:
                    p1_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + threadIdx_x_1] = p1_1[blockIdx_z * 72 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 8)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 15]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 16]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 17]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 30]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 31]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_z_1 * 225 + threadIdx_y_1 * 30 + threadIdx_x_1 * 2 + 32]
    p1_shared_local_1[0] = p1_shared_1[threadIdx_z_1 * 9]
    p1_shared_local_1[1] = p1_shared_1[threadIdx_z_1 * 9 + 1]
    p1_shared_local_1[2] = p1_shared_1[threadIdx_z_1 * 9 + 2]
    p1_shared_local_1[3] = p1_shared_1[threadIdx_z_1 * 9 + 3]
    p1_shared_local_1[4] = p1_shared_1[threadIdx_z_1 * 9 + 4]
    p1_shared_local_1[5] = p1_shared_1[threadIdx_z_1 * 9 + 5]
    p1_shared_local_1[6] = p1_shared_1[threadIdx_z_1 * 9 + 6]
    p1_shared_local_1[7] = p1_shared_1[threadIdx_z_1 * 9 + 7]
    p1_shared_local_1[8] = p1_shared_1[threadIdx_z_1 * 9 + 8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    T_relu_1[blockIdx_z * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + threadIdx_x_1] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z * 8 + threadIdx_z_1], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_16_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((1024,), data=p2)
    T_relu_1 = T.decl_buffer((50176,), data=T_relu)
    p1_1 = T.decl_buffer((524288,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((128,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((25088,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((392,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((7,), data=conv2d_nchw, scope="local", align=4)
    blockIdx_z = T.launch_thread("blockIdx.z", 64)
    conv2d_nchw = T.allocate([14], "float32", "local")
    pad_temp_shared = T.allocate([392], "float32", "shared")
    p1_shared = T.allocate([128], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 7)
    threadIdx_x = T.launch_thread("threadIdx.x", 1)
    conv2d_nchw_1[0] = T.float32(0)
    conv2d_nchw_1[7] = T.float32(0)
    conv2d_nchw_1[1] = T.float32(0)
    conv2d_nchw_1[8] = T.float32(0)
    conv2d_nchw_1[2] = T.float32(0)
    conv2d_nchw_1[9] = T.float32(0)
    conv2d_nchw_1[3] = T.float32(0)
    conv2d_nchw_1[10] = T.float32(0)
    conv2d_nchw_1[4] = T.float32(0)
    conv2d_nchw_1[11] = T.float32(0)
    conv2d_nchw_1[5] = T.float32(0)
    conv2d_nchw_1[12] = T.float32(0)
    conv2d_nchw_1[6] = T.float32(0)
    conv2d_nchw_1[13] = T.float32(0)
    for rc_outer in range(64):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 1)
            T.tvm_storage_sync("shared")
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 1] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 2] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 3] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 4] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 5] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 6] = p0_1[rc_outer * 392 + threadIdx_z_1 * 49 + threadIdx_y_1 * 7 + 6]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 7)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 1)
            if T.shift_right(threadIdx_y_1 * 3, 4) + threadIdx_z_1 < 8:
                if threadIdx_y_1 < 6:
                    p1_shared_1[threadIdx_z_1 * 16 + threadIdx_y_1 * 3] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 3, 3) * 512 + rc_outer * 8 + T.bitwise_and(threadIdx_y_1 * 3, 7)]
            if T.shift_right(threadIdx_y_1 * 3 + 1, 4) + threadIdx_z_1 < 8:
                if threadIdx_y_1 < 5:
                    p1_shared_1[threadIdx_z_1 * 16 + threadIdx_y_1 * 3 + 1] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 3 + 1, 3) * 512 + rc_outer * 8 + T.bitwise_and(threadIdx_y_1 * 3 + 1, 7)]
            if T.shift_right(threadIdx_y_1 * 3 + 2, 4) + threadIdx_z_1 < 8:
                if threadIdx_y_1 < 5:
                    p1_shared_1[threadIdx_z_1 * 16 + threadIdx_y_1 * 3 + 2] = p1_1[blockIdx_z * 8192 + threadIdx_z_1 * 1024 + T.shift_right(threadIdx_y_1 * 3 + 2, 3) * 512 + rc_outer * 8 + T.bitwise_and(threadIdx_y_1 * 3 + 2, 7)]
        T.tvm_storage_sync("shared")
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 1], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 1], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 2], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 2], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 3], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 3], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 4], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 4], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 5], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 5], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 6], p1_shared_1[threadIdx_z * 8], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 6], p1_shared_1[threadIdx_z * 8 + 64], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 49], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 49], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 50], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 50], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 51], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 51], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 52], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 52], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 53], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 53], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 54], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 54], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 55], p1_shared_1[threadIdx_z * 8 + 1], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 55], p1_shared_1[threadIdx_z * 8 + 65], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 98], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 98], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 99], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 99], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 100], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 100], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 101], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 101], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 102], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 102], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 103], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 103], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 104], p1_shared_1[threadIdx_z * 8 + 2], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 104], p1_shared_1[threadIdx_z * 8 + 66], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 147], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 147], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 148], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 148], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 149], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 149], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 150], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 150], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 151], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 151], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 152], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 152], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 153], p1_shared_1[threadIdx_z * 8 + 3], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 153], p1_shared_1[threadIdx_z * 8 + 67], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 196], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 196], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 197], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 197], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 198], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 198], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 199], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 199], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 200], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 200], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 201], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 201], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 202], p1_shared_1[threadIdx_z * 8 + 4], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 202], p1_shared_1[threadIdx_z * 8 + 68], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 245], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 245], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 246], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 246], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 247], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 247], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 248], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 248], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 249], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 249], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 250], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 250], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 251], p1_shared_1[threadIdx_z * 8 + 5], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 251], p1_shared_1[threadIdx_z * 8 + 69], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 294], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 294], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 295], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 295], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 296], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 296], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 297], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 297], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 298], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 298], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 299], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 299], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 300], p1_shared_1[threadIdx_z * 8 + 6], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 300], p1_shared_1[threadIdx_z * 8 + 70], conv2d_nchw_1[13])
        conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 343], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[0])
        conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 343], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[7])
        conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 344], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[1])
        conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 344], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[8])
        conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 345], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[2])
        conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 345], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[9])
        conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 346], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[3])
        conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 346], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[10])
        conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 347], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[4])
        conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 347], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[11])
        conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 348], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[5])
        conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 348], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[12])
        conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 349], p1_shared_1[threadIdx_z * 8 + 7], conv2d_nchw_1[6])
        conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[threadIdx_y * 7 + 349], p1_shared_1[threadIdx_z * 8 + 71], conv2d_nchw_1[13])
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7] = T.max(conv2d_nchw_1[0] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 392] = T.max(conv2d_nchw_1[7] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 1] = T.max(conv2d_nchw_1[1] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 393] = T.max(conv2d_nchw_1[8] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 2] = T.max(conv2d_nchw_1[2] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 394] = T.max(conv2d_nchw_1[9] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 3] = T.max(conv2d_nchw_1[3] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 395] = T.max(conv2d_nchw_1[10] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 4] = T.max(conv2d_nchw_1[4] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 396] = T.max(conv2d_nchw_1[11] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 5] = T.max(conv2d_nchw_1[5] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 397] = T.max(conv2d_nchw_1[12] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 6] = T.max(conv2d_nchw_1[6] + p2_1[blockIdx_z * 16 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_z * 49 + threadIdx_y * 7 + 398] = T.max(conv2d_nchw_1[13] + p2_1[blockIdx_z * 16 + threadIdx_z + 8], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_17_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((1024,), data=p2)
    T_relu_1 = T.decl_buffer((50176,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((1,), data=DepthwiseConv2d, scope="local", align=4)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((9,), data=PaddedInput_shared_local, scope="local", align=32)
    p1_1 = T.decl_buffer((9216,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((50176,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((81,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 1024)
    PaddedInput_shared = T.allocate([81], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([9], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([1], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    for ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer in T.unroll(2):
        threadIdx_z = T.launch_thread("threadIdx.z", 1)
        threadIdx_y = T.launch_thread("threadIdx.y", 7)
        threadIdx_x = T.launch_thread("threadIdx.x", 7)
        if ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x < 81:
            if ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 7 + threadIdx_y < 12:
                PaddedInput_shared_1[ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x] = T.if_then_else(9 <= ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x and ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x < 72 and 1 <= T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 9) and T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 9) < 8, p0_1[blockIdx_z * 49 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 9) * 7 + T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 49 + threadIdx_y * 7 + threadIdx_x, 9) - 8], T.float32(0))
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        threadIdx_y = T.launch_thread("threadIdx.y", 7)
        threadIdx_x = T.launch_thread("threadIdx.x", 7)
        if threadIdx_y * 7 + threadIdx_x < 9:
            if threadIdx_y < 2:
                p1_shared_1[threadIdx_y * 7 + threadIdx_x] = p1_1[blockIdx_z * 9 + threadIdx_y * 7 + threadIdx_x]
    threadIdx_z = T.launch_thread("threadIdx.z", 1)
    threadIdx_y = T.launch_thread("threadIdx.y", 7)
    threadIdx_x = T.launch_thread("threadIdx.x", 7)
    T.tvm_storage_sync("shared")
    for ax2 in T.unroll(3):
        for ax3 in T.unroll(3):
            PaddedInput_shared_local_1[ax2 * 3 + ax3] = PaddedInput_shared_1[ax2 * 9 + threadIdx_y * 9 + ax3 + threadIdx_x]
    for ax2 in T.unroll(3):
        for ax3 in T.unroll(3):
            p1_shared_local_1[ax2 * 3 + ax3] = p1_shared_1[ax2 * 3 + ax3]
    DepthwiseConv2d_1[0] = T.float32(0)
    for di in T.unroll(3):
        for dj in T.unroll(3):
            DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[di * 3 + dj], p1_shared_local_1[di * 3 + dj], DepthwiseConv2d_1[0])
    T_relu_1[blockIdx_z * 49 + threadIdx_y * 7 + threadIdx_x] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_18_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((1024,), data=p2)
    T_relu_1 = T.decl_buffer((50176,), data=T_relu)
    p1_1 = T.decl_buffer((1048576,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((2048,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((50176,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((3136,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((49,), data=conv2d_nchw, scope="local", align=16)
    blockIdx_z = T.launch_thread("blockIdx.z", 32)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([3136], "float32", "shared")
    p1_shared = T.allocate([2048], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 1)
    threadIdx_x = T.launch_thread("threadIdx.x", 7)
    conv2d_nchw_1[0] = T.float32(0)
    conv2d_nchw_1[7] = T.float32(0)
    conv2d_nchw_1[14] = T.float32(0)
    conv2d_nchw_1[21] = T.float32(0)
    conv2d_nchw_1[1] = T.float32(0)
    conv2d_nchw_1[8] = T.float32(0)
    conv2d_nchw_1[15] = T.float32(0)
    conv2d_nchw_1[22] = T.float32(0)
    conv2d_nchw_1[2] = T.float32(0)
    conv2d_nchw_1[9] = T.float32(0)
    conv2d_nchw_1[16] = T.float32(0)
    conv2d_nchw_1[23] = T.float32(0)
    conv2d_nchw_1[3] = T.float32(0)
    conv2d_nchw_1[10] = T.float32(0)
    conv2d_nchw_1[17] = T.float32(0)
    conv2d_nchw_1[24] = T.float32(0)
    conv2d_nchw_1[4] = T.float32(0)
    conv2d_nchw_1[11] = T.float32(0)
    conv2d_nchw_1[18] = T.float32(0)
    conv2d_nchw_1[25] = T.float32(0)
    conv2d_nchw_1[5] = T.float32(0)
    conv2d_nchw_1[12] = T.float32(0)
    conv2d_nchw_1[19] = T.float32(0)
    conv2d_nchw_1[26] = T.float32(0)
    conv2d_nchw_1[6] = T.float32(0)
    conv2d_nchw_1[13] = T.float32(0)
    conv2d_nchw_1[20] = T.float32(0)
    conv2d_nchw_1[27] = T.float32(0)
    for rc_outer in range(16):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
            T.tvm_storage_sync("shared")
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 1] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 2] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 3] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 4] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 5] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 6] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 7] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 8] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 9] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 10] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 11] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 12] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 13] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 1, 7) * 49 + T.truncmod(threadIdx_x_1 + 1, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 14] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 15] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 16] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 17] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 18] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 19] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 20] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 2, 7) * 49 + T.truncmod(threadIdx_x_1 + 2, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 21] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 22] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 23] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 24] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 25] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 26] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 27] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 3, 7) * 49 + T.truncmod(threadIdx_x_1 + 3, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 28] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 29] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 30] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 31] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 32] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 33] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 34] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 4, 7) * 49 + T.truncmod(threadIdx_x_1 + 4, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 35] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 36] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 37] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 38] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 39] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 40] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 41] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 5, 7) * 49 + T.truncmod(threadIdx_x_1 + 5, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 42] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 43] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 1]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 44] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 2]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 45] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 3]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 46] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 4]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 47] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 5]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 48] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + T.Div(threadIdx_x_1 * 8 + 6, 7) * 49 + T.truncmod(threadIdx_x_1 + 6, 7) * 7 + 6]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 49] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 49]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 50] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 50]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 51] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 51]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 52] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 52]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 53] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 53]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 54] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 54]
            pad_temp_shared_1[threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 55] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 392 + threadIdx_x_1 * 56 + 55]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 7)
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 1] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 1, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 1, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 2] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 2, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 2, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 3] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 3, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 3, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 4] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 4, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 4, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 5] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 5, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 5, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 6] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 6, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 6, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 7] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 7, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 7, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 8] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 8, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 8, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 9] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 9, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 9, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 10] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 10, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 10, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 11] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 11, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 11, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 12] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 12, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 12, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 13] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 13, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 13, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 14] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 14, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 14, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 15] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 15, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 15, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 16] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 16, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 16, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 17] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 17, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 17, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 18] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 18, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 18, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 19] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 19, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 19, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 20] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 20, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 20, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 21] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 21, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 21, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 22] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 22, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 22, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 23] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 23, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 23, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 24] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 24, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 24, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 25] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 25, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 25, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 26] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 26, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 26, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 27] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 27, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 27, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 28] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 28, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 28, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 29] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 29, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 29, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 30] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 30, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 30, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 31] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 31, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 31, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 32] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 32, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 32, 63)]
            p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 33] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 33, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 33, 63)]
            if T.shift_right(threadIdx_x_1 * 37 + 34, 8) + threadIdx_z_1 < 8:
                if threadIdx_x_1 < 6:
                    p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 34] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 34, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 34, 63)]
            if T.shift_right(threadIdx_x_1 * 37 + 35, 8) + threadIdx_z_1 < 8:
                if threadIdx_x_1 < 6:
                    p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 35] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 35, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 35, 63)]
            if T.shift_right(threadIdx_x_1 * 37 + 36, 8) + threadIdx_z_1 < 8:
                if threadIdx_x_1 < 6:
                    p1_shared_1[threadIdx_z_1 * 256 + threadIdx_x_1 * 37 + 36] = p1_1[blockIdx_z * 32768 + threadIdx_z_1 * 4096 + T.shift_right(threadIdx_x_1 * 37 + 36, 6) * 1024 + rc_outer * 64 + T.bitwise_and(threadIdx_x_1 * 37 + 36, 63)]
        T.tvm_storage_sync("shared")
        for rc_inner in range(64):
            conv2d_nchw_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[0])
            conv2d_nchw_1[7] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[7])
            conv2d_nchw_1[14] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[14])
            conv2d_nchw_1[21] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[21])
            conv2d_nchw_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 7], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[1])
            conv2d_nchw_1[8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 7], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[8])
            conv2d_nchw_1[15] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 7], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[15])
            conv2d_nchw_1[22] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 7], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[22])
            conv2d_nchw_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 14], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[2])
            conv2d_nchw_1[9] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 14], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[9])
            conv2d_nchw_1[16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 14], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[16])
            conv2d_nchw_1[23] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 14], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[23])
            conv2d_nchw_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 21], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[3])
            conv2d_nchw_1[10] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 21], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[10])
            conv2d_nchw_1[17] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 21], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[17])
            conv2d_nchw_1[24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 21], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[24])
            conv2d_nchw_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 28], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[4])
            conv2d_nchw_1[11] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 28], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[11])
            conv2d_nchw_1[18] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 28], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[18])
            conv2d_nchw_1[25] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 28], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[25])
            conv2d_nchw_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 35], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[5])
            conv2d_nchw_1[12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 35], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[12])
            conv2d_nchw_1[19] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 35], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[19])
            conv2d_nchw_1[26] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 35], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[26])
            conv2d_nchw_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 42], p1_shared_1[threadIdx_z * 64 + rc_inner], conv2d_nchw_1[6])
            conv2d_nchw_1[13] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 42], p1_shared_1[threadIdx_z * 64 + rc_inner + 512], conv2d_nchw_1[13])
            conv2d_nchw_1[20] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 42], p1_shared_1[threadIdx_z * 64 + rc_inner + 1024], conv2d_nchw_1[20])
            conv2d_nchw_1[27] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 49 + threadIdx_x + 42], p1_shared_1[threadIdx_z * 64 + rc_inner + 1536], conv2d_nchw_1[27])
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x] = T.max(conv2d_nchw_1[0] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 392] = T.max(conv2d_nchw_1[7] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 784] = T.max(conv2d_nchw_1[14] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1176] = T.max(conv2d_nchw_1[21] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 7] = T.max(conv2d_nchw_1[1] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 399] = T.max(conv2d_nchw_1[8] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 791] = T.max(conv2d_nchw_1[15] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1183] = T.max(conv2d_nchw_1[22] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 14] = T.max(conv2d_nchw_1[2] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 406] = T.max(conv2d_nchw_1[9] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 798] = T.max(conv2d_nchw_1[16] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1190] = T.max(conv2d_nchw_1[23] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 21] = T.max(conv2d_nchw_1[3] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 413] = T.max(conv2d_nchw_1[10] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 805] = T.max(conv2d_nchw_1[17] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1197] = T.max(conv2d_nchw_1[24] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 28] = T.max(conv2d_nchw_1[4] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 420] = T.max(conv2d_nchw_1[11] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 812] = T.max(conv2d_nchw_1[18] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1204] = T.max(conv2d_nchw_1[25] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 35] = T.max(conv2d_nchw_1[5] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 427] = T.max(conv2d_nchw_1[12] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 819] = T.max(conv2d_nchw_1[19] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1211] = T.max(conv2d_nchw_1[26] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 42] = T.max(conv2d_nchw_1[6] + p2_1[blockIdx_z * 32 + threadIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 434] = T.max(conv2d_nchw_1[13] + p2_1[blockIdx_z * 32 + threadIdx_z + 8], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 826] = T.max(conv2d_nchw_1[20] + p2_1[blockIdx_z * 32 + threadIdx_z + 16], T.float32(0))
    T_relu_1[blockIdx_z * 1568 + threadIdx_z * 49 + threadIdx_x + 1218] = T.max(conv2d_nchw_1[27] + p2_1[blockIdx_z * 32 + threadIdx_z + 24], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_1_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((32,), data=p2)
    T_relu_1 = T.decl_buffer((401408,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((4,), data=DepthwiseConv2d, scope="local", align=16)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((16,), data=PaddedInput_shared_local, scope="local")
    p1_1 = T.decl_buffer((288,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((401408,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((2052,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 32)
    PaddedInput_shared = T.allocate([2052], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([16], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([4], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 7)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    for ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer in T.unroll(5):
        threadIdx_z = T.launch_thread("threadIdx.z", 1)
        threadIdx_y = T.launch_thread("threadIdx.y", 8)
        threadIdx_x = T.launch_thread("threadIdx.x", 56)
        if ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 112 + threadIdx_y * 14 + T.shift_right(threadIdx_x, 2) < 513:
            if ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 8 + threadIdx_y < 37:
                PaddedInput_shared_1[ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 448 + threadIdx_y * 56 + threadIdx_x] = T.if_then_else(1 <= blockIdx_y * 16 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 224 + threadIdx_y * 28 + T.shift_right(threadIdx_x, 1), 57) and blockIdx_y * 16 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 224 + threadIdx_y * 28 + T.shift_right(threadIdx_x, 1), 57) < 113 and 1 <= T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 448 + threadIdx_y * 56 + threadIdx_x, 114) and T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 448 + threadIdx_y * 56 + threadIdx_x, 114) < 113, p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 224 + threadIdx_y * 28 + T.shift_right(threadIdx_x, 1), 57) * 112 + T.truncmod(ax0_ax1_fused_ax2_fused_ax3_fused_outer_outer_outer * 448 + threadIdx_y * 56 + threadIdx_x, 114) - 113], T.float32(0))
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        threadIdx_y = T.launch_thread("threadIdx.y", 8)
        threadIdx_x = T.launch_thread("threadIdx.x", 56)
        if threadIdx_y * 56 + threadIdx_x < 9:
            if threadIdx_y < 1:
                p1_shared_1[threadIdx_y * 56 + threadIdx_x] = p1_1[threadIdx_y * 56 + blockIdx_z * 9 + threadIdx_x]
    threadIdx_z = T.launch_thread("threadIdx.z", 1)
    threadIdx_y = T.launch_thread("threadIdx.y", 8)
    threadIdx_x = T.launch_thread("threadIdx.x", 56)
    T.tvm_storage_sync("shared")
    for ax2 in T.unroll(4):
        for ax3 in T.unroll(4):
            PaddedInput_shared_local_1[ax2 * 4 + ax3] = PaddedInput_shared_1[threadIdx_y * 228 + ax2 * 114 + threadIdx_x * 2 + ax3]
    for ax2 in T.unroll(3):
        for ax3 in T.unroll(3):
            p1_shared_local_1[ax2 * 3 + ax3] = p1_shared_1[ax2 * 3 + ax3]
    for i in T.unroll(2):
        for j in T.unroll(2):
            DepthwiseConv2d_1[i * 2 + j] = T.float32(0)
            for di in T.unroll(3):
                for dj in T.unroll(3):
                    DepthwiseConv2d_1[i * 2 + j] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[i * 4 + di * 4 + j + dj], p1_shared_local_1[di * 3 + dj], DepthwiseConv2d_1[i * 2 + j])
    for ax2_inner_inner_inner in T.unroll(2):
        for ax3_inner_inner_inner in T.unroll(2):
            T_relu_1[blockIdx_z * 12544 + blockIdx_y * 1792 + threadIdx_y * 224 + ax2_inner_inner_inner * 112 + threadIdx_x * 2 + ax3_inner_inner_inner] = T.max(DepthwiseConv2d_1[ax2_inner_inner_inner * 2 + ax3_inner_inner_inner] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_2_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((64,), data=p2)
    T_relu_1 = T.decl_buffer((802816,), data=T_relu)
    p1_1 = T.decl_buffer((2048,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((1024,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((401408,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((1792,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 1)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([1792], "float32", "shared")
    p1_shared = T.allocate([1024], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 112)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 16)
    threadIdx_y = T.launch_thread("threadIdx.y", 1)
    threadIdx_x = T.launch_thread("threadIdx.x", 16)
    for ff_init in T.unroll(4):
        for xx_init in T.unroll(7):
            conv2d_nchw_1[ff_init * 7 + xx_init] = T.float32(0)
    for rc_outer in range(2):
        with T.launch_thread("threadIdx.z", 16) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 16)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(7):
                pad_temp_shared_1[threadIdx_z_1 * 112 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p0_1[rc_outer * 200704 + threadIdx_z_1 * 12544 + blockIdx_y * 112 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        with T.launch_thread("threadIdx.z", 16) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 16)
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(4):
                p1_shared_1[threadIdx_z_1 * 64 + threadIdx_x_1 * 4 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p1_1[threadIdx_z_1 * 128 + T.shift_right(threadIdx_x_1, 2) * 32 + rc_outer * 16 + T.bitwise_and(threadIdx_x_1, 3) * 4 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        T.tvm_storage_sync("shared")
        for rc_inner in T.unroll(16):
            for ff in T.unroll(4):
                for xx in T.unroll(7):
                    conv2d_nchw_1[ff * 7 + xx] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_x * 7 + xx], p1_shared_1[threadIdx_z * 64 + ff * 16 + rc_inner], conv2d_nchw_1[ff * 7 + xx])
    for ax1_inner_inner_inner in T.unroll(4):
        for ax3_inner_inner_inner in T.unroll(7):
            T_relu_1[threadIdx_z * 50176 + ax1_inner_inner_inner * 12544 + blockIdx_y * 112 + threadIdx_x * 7 + ax3_inner_inner_inner] = T.max(conv2d_nchw_1[ax1_inner_inner_inner * 7 + ax3_inner_inner_inner] + p2_1[threadIdx_z * 4 + ax1_inner_inner_inner], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_3_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((64,), data=p2)
    T_relu_1 = T.decl_buffer((200704,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((1,), data=DepthwiseConv2d, scope="local", align=4)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((9,), data=PaddedInput_shared_local, scope="local", align=32)
    p1_1 = T.decl_buffer((576,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((802816,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((1921,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 64)
    PaddedInput_shared = T.allocate([1921], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([9], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([1], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 7)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        T.launch_thread(threadIdx_y, 8)
        T.launch_thread(threadIdx_x, 56)
        PaddedInput_shared_1[threadIdx_y * 56 + threadIdx_x] = T.if_then_else(1 <= blockIdx_y * 16 + T.Div(threadIdx_y * 56 + threadIdx_x, 113) and 1 <= T.truncmod(threadIdx_y * 56 + threadIdx_x, 113), p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(threadIdx_y * 56 + threadIdx_x, 113) * 112 + T.truncmod(threadIdx_y * 56 + threadIdx_x, 113) - 113], T.float32(0))
    threadIdx_z = T.env_thread("threadIdx.z")
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 8)
        T.launch_thread(threadIdx_x, 56)
        PaddedInput_shared_1[threadIdx_y * 56 + threadIdx_x + 448] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 56 + threadIdx_x + 109, 113), p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(threadIdx_y * 56 + threadIdx_x + 448, 113) * 112 + T.truncmod(threadIdx_y * 56 + threadIdx_x + 109, 113) - 113], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 8)
        T.launch_thread(threadIdx_x, 56)
        PaddedInput_shared_1[threadIdx_y * 56 + threadIdx_x + 896] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 56 + threadIdx_x + 105, 113), p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(threadIdx_y * 56 + threadIdx_x + 896, 113) * 112 + T.truncmod(threadIdx_y * 56 + threadIdx_x + 105, 113) - 113], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 8)
        T.launch_thread(threadIdx_x, 56)
        PaddedInput_shared_1[threadIdx_y * 56 + threadIdx_x + 1344] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 56 + threadIdx_x + 101, 113), p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(threadIdx_y * 56 + threadIdx_x + 1344, 113) * 112 + T.truncmod(threadIdx_y * 56 + threadIdx_x + 101, 113) - 113], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 8)
        T.launch_thread(threadIdx_x, 56)
        if threadIdx_y * 56 + threadIdx_x < 129:
            if threadIdx_y < 3:
                PaddedInput_shared_1[threadIdx_y * 56 + threadIdx_x + 1792] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 56 + threadIdx_x + 97, 113), p0_1[blockIdx_z * 12544 + blockIdx_y * 1792 + T.Div(threadIdx_y * 56 + threadIdx_x + 1792, 113) * 112 + T.truncmod(threadIdx_y * 56 + threadIdx_x + 97, 113) - 113], T.float32(0))
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 8)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 56)
        if threadIdx_y_1 * 56 + threadIdx_x_1 < 9:
            if threadIdx_y_1 < 1:
                p1_shared_1[threadIdx_y_1 * 56 + threadIdx_x_1] = p1_1[threadIdx_y_1 * 56 + blockIdx_z * 9 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 1)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 8)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 56)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 113]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 114]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 115]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 226]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 227]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_y_1 * 226 + threadIdx_x_1 * 2 + 228]
    p1_shared_local_1[0] = p1_shared_1[0]
    p1_shared_local_1[1] = p1_shared_1[1]
    p1_shared_local_1[2] = p1_shared_1[2]
    p1_shared_local_1[3] = p1_shared_1[3]
    p1_shared_local_1[4] = p1_shared_1[4]
    p1_shared_local_1[5] = p1_shared_1[5]
    p1_shared_local_1[6] = p1_shared_1[6]
    p1_shared_local_1[7] = p1_shared_1[7]
    p1_shared_local_1[8] = p1_shared_1[8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    T_relu_1[blockIdx_z * 3136 + blockIdx_y * 448 + threadIdx_y_1 * 56 + threadIdx_x_1] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_4_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((128,), data=p2)
    T_relu_1 = T.decl_buffer((401408,), data=T_relu)
    p1_1 = T.decl_buffer((8192,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((128,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((200704,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((448,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((64,), data=conv2d_nchw, scope="local", align=32)
    blockIdx_z = T.launch_thread("blockIdx.z", 4)
    conv2d_nchw = T.allocate([56], "float32", "local")
    pad_temp_shared = T.allocate([448], "float32", "shared")
    p1_shared = T.allocate([128], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 28)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 4)
    threadIdx_y = T.launch_thread("threadIdx.y", 2)
    threadIdx_x = T.launch_thread("threadIdx.x", 8)
    for ff_init in T.unroll(8):
        conv2d_nchw_1[ff_init] = T.float32(0)
        conv2d_nchw_1[ff_init + 8] = T.float32(0)
        conv2d_nchw_1[ff_init + 16] = T.float32(0)
        conv2d_nchw_1[ff_init + 24] = T.float32(0)
        conv2d_nchw_1[ff_init + 32] = T.float32(0)
        conv2d_nchw_1[ff_init + 40] = T.float32(0)
        conv2d_nchw_1[ff_init + 48] = T.float32(0)
    for rc_outer in range(16):
        with T.launch_thread("threadIdx.z", 4) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 2)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 8)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(7):
                pad_temp_shared_1[threadIdx_z_1 * 112 + threadIdx_y_1 * 56 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p0_1[rc_outer * 12544 + threadIdx_z_1 * 3136 + blockIdx_y * 112 + threadIdx_y_1 * 56 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        with T.launch_thread("threadIdx.z", 4) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 2)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 8)
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(2):
                p1_shared_1[threadIdx_z_1 * 32 + threadIdx_y_1 * 16 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p1_1[blockIdx_z * 2048 + threadIdx_z_1 * 512 + threadIdx_y_1 * 256 + T.shift_right(threadIdx_x_1, 1) * 64 + rc_outer * 4 + T.bitwise_and(threadIdx_x_1, 1) * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        T.tvm_storage_sync("shared")
        for rc_inner in T.unroll(4):
            for ff in T.unroll(8):
                conv2d_nchw_1[ff] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff])
                conv2d_nchw_1[ff + 8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 8], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 8])
                conv2d_nchw_1[ff + 16] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 16], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 16])
                conv2d_nchw_1[ff + 24] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 24], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 24])
                conv2d_nchw_1[ff + 32] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 32], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 32])
                conv2d_nchw_1[ff + 40] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 40], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 40])
                conv2d_nchw_1[ff + 48] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 56 + threadIdx_x + 48], p1_shared_1[threadIdx_z * 32 + ff * 4 + rc_inner], conv2d_nchw_1[ff + 48])
    for ax1_inner_inner_inner in T.unroll(8):
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x] = T.max(conv2d_nchw_1[ax1_inner_inner_inner] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 8] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 8] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 16] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 16] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 24] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 24] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 32] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 32] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 40] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 40] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 25088 + ax1_inner_inner_inner * 3136 + blockIdx_y * 112 + threadIdx_y * 56 + threadIdx_x + 48] = T.max(conv2d_nchw_1[ax1_inner_inner_inner + 48] + p2_1[blockIdx_z * 32 + threadIdx_z * 8 + ax1_inner_inner_inner], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_5_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((128,), data=p2)
    T_relu_1 = T.decl_buffer((401408,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((4,), data=DepthwiseConv2d, scope="local", align=16)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((16,), data=PaddedInput_shared_local, scope="local")
    p1_1 = T.decl_buffer((1152,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((401408,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((1740,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 128)
    PaddedInput_shared = T.allocate([1740], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([16], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([4], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 2)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        T.launch_thread(threadIdx_y, 14)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x] = T.if_then_else(1 <= blockIdx_y * 28 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1), 29) and 1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x, 58) and T.truncmod(threadIdx_y * 28 + threadIdx_x, 58) < 57, p0_1[blockIdx_z * 3136 + blockIdx_y * 1568 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1), 29) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x, 58) - 57], T.float32(0))
    threadIdx_z = T.env_thread("threadIdx.z")
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 14)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 392] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 44, 58) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 44, 58) < 57, p0_1[blockIdx_z * 3136 + blockIdx_y * 1568 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 196, 29) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 44, 58) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 14)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 784] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 30, 58) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 30, 58) < 57, p0_1[blockIdx_z * 3136 + blockIdx_y * 1568 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 392, 29) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 30, 58) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 14)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 1176] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 16, 58) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 16, 58) < 57, p0_1[blockIdx_z * 3136 + blockIdx_y * 1568 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 588, 29) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 16, 58) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 14)
        T.launch_thread(threadIdx_x, 28)
        if threadIdx_y * 7 + T.shift_right(threadIdx_x, 2) < 43:
            if threadIdx_y < 7:
                PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 1568] = T.if_then_else(blockIdx_y * 28 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 784, 29) < 57 and 1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 2, 58) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 2, 58) < 57, p0_1[blockIdx_z * 3136 + blockIdx_y * 1568 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 784, 29) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 2, 58) - 57], T.float32(0))
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 14)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
        if threadIdx_y_1 * 28 + threadIdx_x_1 < 9:
            if threadIdx_y_1 < 1:
                p1_shared_1[threadIdx_y_1 * 28 + threadIdx_x_1] = p1_1[threadIdx_y_1 * 28 + blockIdx_z * 9 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 1)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 14)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 3]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 58]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 59]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 60]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 61]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 116]
    PaddedInput_shared_local_1[9] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 117]
    PaddedInput_shared_local_1[10] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 118]
    PaddedInput_shared_local_1[11] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 119]
    PaddedInput_shared_local_1[12] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 174]
    PaddedInput_shared_local_1[13] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 175]
    PaddedInput_shared_local_1[14] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 176]
    PaddedInput_shared_local_1[15] = PaddedInput_shared_1[threadIdx_y_1 * 116 + threadIdx_x_1 * 2 + 177]
    p1_shared_local_1[0] = p1_shared_1[0]
    p1_shared_local_1[1] = p1_shared_1[1]
    p1_shared_local_1[2] = p1_shared_1[2]
    p1_shared_local_1[3] = p1_shared_1[3]
    p1_shared_local_1[4] = p1_shared_1[4]
    p1_shared_local_1[5] = p1_shared_1[5]
    p1_shared_local_1[6] = p1_shared_1[6]
    p1_shared_local_1[7] = p1_shared_1[7]
    p1_shared_local_1[8] = p1_shared_1[8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[1] = T.float32(0)
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[0], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[1], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[2], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[3], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[4], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[5], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[6], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[7], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[8], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[2] = T.float32(0)
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[0], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[1], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[2], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[3], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[4], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[5], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[6], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[7], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[8], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[3] = T.float32(0)
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[0], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[1], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[2], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[3], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[4], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[5], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[6], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[7], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[15], p1_shared_local_1[8], DepthwiseConv2d_1[3])
    T_relu_1[blockIdx_z * 3136 + blockIdx_y * 1568 + threadIdx_y_1 * 112 + threadIdx_x_1 * 2] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 3136 + blockIdx_y * 1568 + threadIdx_y_1 * 112 + threadIdx_x_1 * 2 + 1] = T.max(DepthwiseConv2d_1[1] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 3136 + blockIdx_y * 1568 + threadIdx_y_1 * 112 + threadIdx_x_1 * 2 + 56] = T.max(DepthwiseConv2d_1[2] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 3136 + blockIdx_y * 1568 + threadIdx_y_1 * 112 + threadIdx_x_1 * 2 + 57] = T.max(DepthwiseConv2d_1[3] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_6_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((128,), data=p2)
    T_relu_1 = T.decl_buffer((401408,), data=T_relu)
    p1_1 = T.decl_buffer((16384,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((256,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((401408,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((896,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 4)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([896], "float32", "shared")
    p1_shared = T.allocate([256], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 14)
    blockIdx_x = T.launch_thread("blockIdx.x", 2)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 4)
    threadIdx_x = T.launch_thread("threadIdx.x", 4)
    for ff_init, xx_init in T.grid(4, 7):
        conv2d_nchw_1[ff_init * 7 + xx_init] = T.float32(0)
    for rc_outer in range(16):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in range(7):
                pad_temp_shared_1[threadIdx_z_1 * 112 + threadIdx_y_1 * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p0_1[rc_outer * 25088 + threadIdx_z_1 * 3136 + blockIdx_y * 224 + threadIdx_y_1 * 56 + blockIdx_x * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in range(2):
                p1_shared_1[threadIdx_z_1 * 32 + threadIdx_y_1 * 8 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p1_1[blockIdx_z * 4096 + threadIdx_z_1 * 512 + threadIdx_y_1 * 128 + rc_outer * 8 + threadIdx_x_1 * 2 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        T.tvm_storage_sync("shared")
        for rc_inner, ff, xx in T.grid(8, 4, 7):
            conv2d_nchw_1[ff * 7 + xx] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 28 + threadIdx_x * 7 + xx], p1_shared_1[threadIdx_z * 32 + ff * 8 + rc_inner], conv2d_nchw_1[ff * 7 + xx])
    for ax1_inner_inner_inner, ax3_inner_inner_inner in T.grid(4, 7):
        T_relu_1[blockIdx_z * 100352 + threadIdx_z * 12544 + ax1_inner_inner_inner * 3136 + blockIdx_y * 224 + threadIdx_y * 56 + blockIdx_x * 28 + threadIdx_x * 7 + ax3_inner_inner_inner] = T.max(conv2d_nchw_1[ax1_inner_inner_inner * 7 + ax3_inner_inner_inner] + p2_1[blockIdx_z * 32 + threadIdx_z * 4 + ax1_inner_inner_inner], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_7_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((128,), data=p2)
    T_relu_1 = T.decl_buffer((100352,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((2,), data=DepthwiseConv2d, scope="local", align=8)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((15,), data=PaddedInput_shared_local, scope="local", align=32)
    p1_1 = T.decl_buffer((1152,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((401408,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((513,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 128)
    PaddedInput_shared = T.allocate([513], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([15], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([2], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 7)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x] = T.if_then_else(1 <= blockIdx_y and 1 <= threadIdx_y * 28 + threadIdx_x, p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + threadIdx_y * 28 + threadIdx_x - 57], T.float32(0))
    threadIdx_z = T.env_thread("threadIdx.z")
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 56] = T.if_then_else(1 <= blockIdx_y * 8 + T.Div(threadIdx_y * 28 + threadIdx_x + 56, 57) and 1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 56, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 56, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 56, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 112] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 55, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 112, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 55, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 168] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 54, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 168, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 54, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 224] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 53, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 224, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 53, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 280] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 52, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 280, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 52, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 336] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 51, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 336, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 51, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 392] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 50, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 392, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 50, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 448] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 49, 57), p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 448, 57) * 56 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 49, 57) - 57], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 2)
        T.launch_thread(threadIdx_x, 28)
        if threadIdx_y * 28 + threadIdx_x < 9:
            if threadIdx_y < 1:
                PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 504] = p0_1[blockIdx_z * 3136 + blockIdx_y * 448 + T.Div(threadIdx_y * 28 + threadIdx_x + 504, 57) * 56 + threadIdx_y * 28 + threadIdx_x - 9]
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 2)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
        if threadIdx_y_1 * 28 + threadIdx_x_1 < 9:
            if threadIdx_y_1 < 1:
                p1_shared_1[threadIdx_y_1 * 28 + threadIdx_x_1] = p1_1[threadIdx_y_1 * 28 + blockIdx_z * 9 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 1)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 2)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 57]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 58]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 59]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 114]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 115]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 116]
    PaddedInput_shared_local_1[9] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 171]
    PaddedInput_shared_local_1[10] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 172]
    PaddedInput_shared_local_1[11] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 173]
    PaddedInput_shared_local_1[12] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 228]
    PaddedInput_shared_local_1[13] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 229]
    PaddedInput_shared_local_1[14] = PaddedInput_shared_1[threadIdx_y_1 * 228 + threadIdx_x_1 * 2 + 230]
    p1_shared_local_1[0] = p1_shared_1[0]
    p1_shared_local_1[1] = p1_shared_1[1]
    p1_shared_local_1[2] = p1_shared_1[2]
    p1_shared_local_1[3] = p1_shared_1[3]
    p1_shared_local_1[4] = p1_shared_1[4]
    p1_shared_local_1[5] = p1_shared_1[5]
    p1_shared_local_1[6] = p1_shared_1[6]
    p1_shared_local_1[7] = p1_shared_1[7]
    p1_shared_local_1[8] = p1_shared_1[8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[1] = T.float32(0)
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[0], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[1], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[2], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[3], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[4], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[5], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[6], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[7], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[8], DepthwiseConv2d_1[1])
    T_relu_1[blockIdx_z * 784 + blockIdx_y * 112 + threadIdx_y_1 * 56 + threadIdx_x_1] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + blockIdx_y * 112 + threadIdx_y_1 * 56 + threadIdx_x_1 + 28] = T.max(DepthwiseConv2d_1[1] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_8_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((256,), data=p2)
    T_relu_1 = T.decl_buffer((200704,), data=T_relu)
    p1_1 = T.decl_buffer((32768,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((64,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((100352,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((448,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((28,), data=conv2d_nchw, scope="local")
    blockIdx_z = T.launch_thread("blockIdx.z", 16)
    conv2d_nchw = T.allocate([28], "float32", "local")
    pad_temp_shared = T.allocate([448], "float32", "shared")
    p1_shared = T.allocate([64], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 7)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_z = T.launch_thread("threadIdx.z", 4)
    threadIdx_y = T.launch_thread("threadIdx.y", 4)
    threadIdx_x = T.launch_thread("threadIdx.x", 4)
    for ff_init, xx_init in T.grid(4, 7):
        conv2d_nchw_1[ff_init * 7 + xx_init] = T.float32(0)
    for rc_outer in range(32):
        with T.launch_thread("threadIdx.z", 4) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in range(7):
                pad_temp_shared_1[threadIdx_z_1 * 112 + threadIdx_y_1 * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p0_1[rc_outer * 3136 + threadIdx_z_1 * 784 + blockIdx_y * 112 + threadIdx_y_1 * 28 + threadIdx_x_1 * 7 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        with T.launch_thread("threadIdx.z", 4) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 4)
            p1_shared_1[threadIdx_z_1 * 16 + threadIdx_y_1 * 4 + threadIdx_x_1] = p1_1[blockIdx_z * 2048 + threadIdx_z_1 * 512 + threadIdx_y_1 * 128 + rc_outer * 4 + threadIdx_x_1]
        T.tvm_storage_sync("shared")
        for rc_inner, ff, xx in T.grid(4, 4, 7):
            conv2d_nchw_1[ff * 7 + xx] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[rc_inner * 112 + threadIdx_y * 28 + threadIdx_x * 7 + xx], p1_shared_1[threadIdx_z * 16 + ff * 4 + rc_inner], conv2d_nchw_1[ff * 7 + xx])
    for ax1_inner_inner_inner, ax3_inner_inner_inner in T.grid(4, 7):
        T_relu_1[blockIdx_z * 12544 + threadIdx_z * 3136 + ax1_inner_inner_inner * 784 + blockIdx_y * 112 + threadIdx_y * 28 + threadIdx_x * 7 + ax3_inner_inner_inner] = T.max(conv2d_nchw_1[ax1_inner_inner_inner * 7 + ax3_inner_inner_inner] + p2_1[blockIdx_z * 16 + threadIdx_z * 4 + ax1_inner_inner_inner], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_9_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((256,), data=p2)
    T_relu_1 = T.decl_buffer((200704,), data=T_relu)
    DepthwiseConv2d = T.handle("float32", "local")
    DepthwiseConv2d_1 = T.decl_buffer((7,), data=DepthwiseConv2d, scope="local", align=16)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((9,), data=p1_shared_local, scope="local", align=32)
    PaddedInput_shared_local = T.handle("float32", "local")
    PaddedInput_shared_local_1 = T.decl_buffer((27,), data=PaddedInput_shared_local, scope="local")
    p1_1 = T.decl_buffer((2304,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((9,), data=p1_shared, scope="shared", align=32)
    p0_1 = T.decl_buffer((200704,), data=p0)
    PaddedInput_shared = T.handle("float32", "shared")
    PaddedInput_shared_1 = T.decl_buffer((900,), data=PaddedInput_shared, scope="shared")
    blockIdx_z = T.launch_thread("blockIdx.z", 256)
    PaddedInput_shared = T.allocate([900], "float32", "shared")
    p1_shared = T.allocate([9], "float32", "shared")
    PaddedInput_shared_local = T.allocate([27], "float32", "local")
    p1_shared_local = T.allocate([9], "float32", "local")
    DepthwiseConv2d = T.allocate([7], "float32", "local")
    blockIdx_y = T.launch_thread("blockIdx.y", 1)
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.env_thread("threadIdx.y")
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z:
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x] = T.if_then_else(15 <= threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) and 1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1), 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x, 30) - 29], T.float32(0))
    threadIdx_z = T.env_thread("threadIdx.z")
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 112] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 22, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 22, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 56, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 22, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 224] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 14, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 14, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 112, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 14, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 336] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 6, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 6, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 168, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 6, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 448] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 28, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 28, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 224, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 28, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 560] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 20, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 20, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 280, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 20, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 672] = T.if_then_else(1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 12, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 12, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 336, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 12, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 784] = T.if_then_else(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) < 43 and 1 <= T.truncmod(threadIdx_y * 28 + threadIdx_x + 4, 30) and T.truncmod(threadIdx_y * 28 + threadIdx_x + 4, 30) < 29, p0_1[blockIdx_z * 784 + T.Div(threadIdx_y * 14 + T.shift_right(threadIdx_x, 1) + 392, 15) * 28 + T.truncmod(threadIdx_y * 28 + threadIdx_x + 4, 30) - 29], T.float32(0))
    with T.launch_thread(threadIdx_z, 1):
        T.launch_thread(threadIdx_y, 4)
        T.launch_thread(threadIdx_x, 28)
        if threadIdx_y * 7 + T.shift_right(threadIdx_x, 2) < 1:
            if threadIdx_y < 1:
                PaddedInput_shared_1[threadIdx_y * 28 + threadIdx_x + 896] = T.float32(0)
    with T.launch_thread("threadIdx.z", 1) as threadIdx_z_1:
        threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
        threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
        if threadIdx_y_1 * 28 + threadIdx_x_1 < 9:
            if threadIdx_y_1 < 1:
                p1_shared_1[threadIdx_y_1 * 28 + threadIdx_x_1] = p1_1[threadIdx_y_1 * 28 + blockIdx_z * 9 + threadIdx_x_1]
    threadIdx_z_1 = T.launch_thread("threadIdx.z", 1)
    threadIdx_y_1 = T.launch_thread("threadIdx.y", 4)
    threadIdx_x_1 = T.launch_thread("threadIdx.x", 28)
    T.tvm_storage_sync("shared")
    PaddedInput_shared_local_1[0] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1]
    PaddedInput_shared_local_1[1] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 1]
    PaddedInput_shared_local_1[2] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 2]
    PaddedInput_shared_local_1[3] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 30]
    PaddedInput_shared_local_1[4] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 31]
    PaddedInput_shared_local_1[5] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 32]
    PaddedInput_shared_local_1[6] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 60]
    PaddedInput_shared_local_1[7] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 61]
    PaddedInput_shared_local_1[8] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 62]
    PaddedInput_shared_local_1[9] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 90]
    PaddedInput_shared_local_1[10] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 91]
    PaddedInput_shared_local_1[11] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 92]
    PaddedInput_shared_local_1[12] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 120]
    PaddedInput_shared_local_1[13] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 121]
    PaddedInput_shared_local_1[14] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 122]
    PaddedInput_shared_local_1[15] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 150]
    PaddedInput_shared_local_1[16] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 151]
    PaddedInput_shared_local_1[17] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 152]
    PaddedInput_shared_local_1[18] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 180]
    PaddedInput_shared_local_1[19] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 181]
    PaddedInput_shared_local_1[20] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 182]
    PaddedInput_shared_local_1[21] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 210]
    PaddedInput_shared_local_1[22] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 211]
    PaddedInput_shared_local_1[23] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 212]
    PaddedInput_shared_local_1[24] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 240]
    PaddedInput_shared_local_1[25] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 241]
    PaddedInput_shared_local_1[26] = PaddedInput_shared_1[threadIdx_y_1 * 210 + threadIdx_x_1 + 242]
    p1_shared_local_1[0] = p1_shared_1[0]
    p1_shared_local_1[1] = p1_shared_1[1]
    p1_shared_local_1[2] = p1_shared_1[2]
    p1_shared_local_1[3] = p1_shared_1[3]
    p1_shared_local_1[4] = p1_shared_1[4]
    p1_shared_local_1[5] = p1_shared_1[5]
    p1_shared_local_1[6] = p1_shared_1[6]
    p1_shared_local_1[7] = p1_shared_1[7]
    p1_shared_local_1[8] = p1_shared_1[8]
    DepthwiseConv2d_1[0] = T.float32(0)
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[0], p1_shared_local_1[0], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[1], p1_shared_local_1[1], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[2], p1_shared_local_1[2], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[3], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[4], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[5], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[6], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[7], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[0] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[8], DepthwiseConv2d_1[0])
    DepthwiseConv2d_1[1] = T.float32(0)
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[3], p1_shared_local_1[0], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[4], p1_shared_local_1[1], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[5], p1_shared_local_1[2], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[3], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[4], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[5], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[6], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[7], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[1] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[8], DepthwiseConv2d_1[1])
    DepthwiseConv2d_1[2] = T.float32(0)
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[6], p1_shared_local_1[0], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[7], p1_shared_local_1[1], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[8], p1_shared_local_1[2], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[3], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[4], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[5], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[6], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[7], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[8], DepthwiseConv2d_1[2])
    DepthwiseConv2d_1[3] = T.float32(0)
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[9], p1_shared_local_1[0], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[10], p1_shared_local_1[1], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[11], p1_shared_local_1[2], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[3], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[4], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[5], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[15], p1_shared_local_1[6], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[16], p1_shared_local_1[7], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[3] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[17], p1_shared_local_1[8], DepthwiseConv2d_1[3])
    DepthwiseConv2d_1[4] = T.float32(0)
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[12], p1_shared_local_1[0], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[13], p1_shared_local_1[1], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[14], p1_shared_local_1[2], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[15], p1_shared_local_1[3], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[16], p1_shared_local_1[4], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[17], p1_shared_local_1[5], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[18], p1_shared_local_1[6], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[19], p1_shared_local_1[7], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[20], p1_shared_local_1[8], DepthwiseConv2d_1[4])
    DepthwiseConv2d_1[5] = T.float32(0)
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[15], p1_shared_local_1[0], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[16], p1_shared_local_1[1], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[17], p1_shared_local_1[2], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[18], p1_shared_local_1[3], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[19], p1_shared_local_1[4], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[20], p1_shared_local_1[5], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[21], p1_shared_local_1[6], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[22], p1_shared_local_1[7], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[5] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[23], p1_shared_local_1[8], DepthwiseConv2d_1[5])
    DepthwiseConv2d_1[6] = T.float32(0)
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[18], p1_shared_local_1[0], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[19], p1_shared_local_1[1], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[20], p1_shared_local_1[2], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[21], p1_shared_local_1[3], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[22], p1_shared_local_1[4], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[23], p1_shared_local_1[5], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[24], p1_shared_local_1[6], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[25], p1_shared_local_1[7], DepthwiseConv2d_1[6])
    DepthwiseConv2d_1[6] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), PaddedInput_shared_local_1[26], p1_shared_local_1[8], DepthwiseConv2d_1[6])
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1] = T.max(DepthwiseConv2d_1[0] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 28] = T.max(DepthwiseConv2d_1[1] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 56] = T.max(DepthwiseConv2d_1[2] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 84] = T.max(DepthwiseConv2d_1[3] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 112] = T.max(DepthwiseConv2d_1[4] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 140] = T.max(DepthwiseConv2d_1[5] + p2_1[blockIdx_z], T.float32(0))
    T_relu_1[blockIdx_z * 784 + threadIdx_y_1 * 196 + threadIdx_x_1 + 168] = T.max(DepthwiseConv2d_1[6] + p2_1[blockIdx_z], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_conv2d_add_nn_relu_kernel(T_relu: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.z", "blockIdx.y", "blockIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x", "threadIdx.z", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((32,), data=p2)
    T_relu_1 = T.decl_buffer((401408,), data=T_relu)
    p1_1 = T.decl_buffer((864,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((288,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((150528,), data=p0)
    pad_temp_shared = T.handle("float32", "shared")
    pad_temp_shared_1 = T.decl_buffer((297,), data=pad_temp_shared, scope="shared")
    conv2d_nchw = T.handle("float32", "local")
    conv2d_nchw_1 = T.decl_buffer((16,), data=conv2d_nchw, scope="local", align=16)
    blockIdx_z = T.launch_thread("blockIdx.z", 1)
    conv2d_nchw = T.allocate([16], "float32", "local")
    pad_temp_shared = T.allocate([297], "float32", "shared")
    p1_shared = T.allocate([288], "float32", "shared")
    blockIdx_y = T.launch_thread("blockIdx.y", 28)
    blockIdx_x = T.launch_thread("blockIdx.x", 7)
    threadIdx_z = T.launch_thread("threadIdx.z", 8)
    threadIdx_y = T.launch_thread("threadIdx.y", 1)
    threadIdx_x = T.launch_thread("threadIdx.x", 16)
    for yy_init in T.unroll(4):
        conv2d_nchw_1[yy_init] = T.float32(0)
        conv2d_nchw_1[yy_init + 4] = T.float32(0)
        conv2d_nchw_1[yy_init + 8] = T.float32(0)
        conv2d_nchw_1[yy_init + 12] = T.float32(0)
    for rc_outer in T.unroll(3):
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 16)
            T.tvm_storage_sync("shared")
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(3):
                if threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner < 297:
                    if threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner < 38:
                        pad_temp_shared_1[threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = T.if_then_else(1 <= blockIdx_y * 8 + T.Div(threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner, 33) and 1 <= blockIdx_x * 32 + T.truncmod(threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner, 33), p0_1[rc_outer * 50176 + blockIdx_y * 1792 + T.Div(threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner, 33) * 224 + blockIdx_x * 32 + T.truncmod(threadIdx_z_1 * 38 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner, 33) - 225], T.float32(0))
        with T.launch_thread("threadIdx.z", 8) as threadIdx_z_1:
            threadIdx_y_1 = T.launch_thread("threadIdx.y", 1)
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 16)
            for ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner in T.unroll(3):
                if T.Div(threadIdx_x_1, 12) + threadIdx_z_1 < 8:
                    if threadIdx_x_1 < 12:
                        p1_shared_1[threadIdx_z_1 * 36 + threadIdx_x_1 * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner] = p1_1[threadIdx_z_1 * 108 + T.Div(threadIdx_x_1, 3) * 27 + rc_outer * 9 + T.truncmod(threadIdx_x_1, 3) * 3 + ax0_ax1_fused_ax2_fused_ax3_fused_inner_inner_inner]
        T.tvm_storage_sync("shared")
        for ry_inner in T.unroll(3):
            for rx_inner in T.unroll(3):
                for yy in T.unroll(4):
                    conv2d_nchw_1[yy] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[yy * 66 + ry_inner * 33 + threadIdx_x * 2 + rx_inner], p1_shared_1[threadIdx_z * 9 + ry_inner * 3 + rx_inner], conv2d_nchw_1[yy])
                    conv2d_nchw_1[yy + 4] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[yy * 66 + ry_inner * 33 + threadIdx_x * 2 + rx_inner], p1_shared_1[threadIdx_z * 9 + ry_inner * 3 + rx_inner + 72], conv2d_nchw_1[yy + 4])
                    conv2d_nchw_1[yy + 8] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[yy * 66 + ry_inner * 33 + threadIdx_x * 2 + rx_inner], p1_shared_1[threadIdx_z * 9 + ry_inner * 3 + rx_inner + 144], conv2d_nchw_1[yy + 8])
                    conv2d_nchw_1[yy + 12] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), pad_temp_shared_1[yy * 66 + ry_inner * 33 + threadIdx_x * 2 + rx_inner], p1_shared_1[threadIdx_z * 9 + ry_inner * 3 + rx_inner + 216], conv2d_nchw_1[yy + 12])
    for ax2_inner_inner_inner in T.unroll(4):
        T_relu_1[threadIdx_z * 12544 + blockIdx_y * 448 + ax2_inner_inner_inner * 112 + blockIdx_x * 16 + threadIdx_x] = T.max(conv2d_nchw_1[ax2_inner_inner_inner] + p2_1[threadIdx_z], T.float32(0))
        T_relu_1[threadIdx_z * 12544 + blockIdx_y * 448 + ax2_inner_inner_inner * 112 + blockIdx_x * 16 + threadIdx_x + 100352] = T.max(conv2d_nchw_1[ax2_inner_inner_inner + 4] + p2_1[threadIdx_z + 8], T.float32(0))
        T_relu_1[threadIdx_z * 12544 + blockIdx_y * 448 + ax2_inner_inner_inner * 112 + blockIdx_x * 16 + threadIdx_x + 200704] = T.max(conv2d_nchw_1[ax2_inner_inner_inner + 8] + p2_1[threadIdx_z + 16], T.float32(0))
        T_relu_1[threadIdx_z * 12544 + blockIdx_y * 448 + ax2_inner_inner_inner * 112 + blockIdx_x * 16 + threadIdx_x + 301056] = T.max(conv2d_nchw_1[ax2_inner_inner_inner + 12] + p2_1[threadIdx_z + 24], T.float32(0))
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_llvm.cc:1890: Warning: Unroll hint get ignore at CodeGenLLVM backend,  consider set unroll_explicit=True
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_dense_add_kernel(T_add: T.handle("float32"), p0: T.handle("float32"), p1: T.handle("float32"), p2: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.y", "blockIdx.x", "threadIdx.y", "threadIdx.x", "threadIdx.y", "threadIdx.x", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    p2_1 = T.decl_buffer((1000,), data=p2)
    T_add_1 = T.decl_buffer((1000,), data=T_add)
    p1_shared_local = T.handle("float32", "local")
    p1_shared_local_1 = T.decl_buffer((4,), data=p1_shared_local, scope="local", align=8)
    p0_shared_local = T.handle("float32", "local")
    p0_shared_local_1 = T.decl_buffer((1,), data=p0_shared_local, scope="local", align=4)
    p1_shared_local_2 = T.handle("float32", "local")
    p1_shared_local_3 = T.decl_buffer((4,), data=p1_shared_local_2, scope="local", align=8)
    p0_shared_local_2 = T.handle("float32", "local")
    p0_shared_local_3 = T.decl_buffer((1,), data=p0_shared_local_2, scope="local", align=4)
    p1_1 = T.decl_buffer((1024000,), data=p1)
    p1_shared = T.handle("float32", "shared")
    p1_shared_1 = T.decl_buffer((1024,), data=p1_shared, scope="shared")
    p0_1 = T.decl_buffer((1024,), data=p0)
    p0_shared = T.handle("float32", "shared")
    p0_shared_1 = T.decl_buffer((16,), data=p0_shared, scope="shared", align=32)
    T_matmul_NT_local = T.handle("float32", "local")
    T_matmul_NT_local_1 = T.decl_buffer((4,), data=T_matmul_NT_local, scope="local", align=8)
    blockIdx_y = T.launch_thread("blockIdx.y", 16)
    T_matmul_NT_local = T.allocate([4], "float32", "local")
    p0_shared = T.allocate([16], "float32", "shared")
    p1_shared = T.allocate([1024], "float32", "shared")
    p0_shared_local_2 = T.allocate([1], "float32", "local")
    p1_shared_local_2 = T.allocate([4], "float32", "local")
    p0_shared_local = T.allocate([1], "float32", "local")
    p1_shared_local = T.allocate([4], "float32", "local")
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    threadIdx_y = T.launch_thread("threadIdx.y", 16)
    threadIdx_x = T.launch_thread("threadIdx.x", 1)
    for j_c_init in range(2):
        T_matmul_NT_local_1[j_c_init] = T.float32(0)
        T_matmul_NT_local_1[j_c_init + 2] = T.float32(0)
    with T.launch_thread("threadIdx.y", 1) as threadIdx_y_1:
        for ax1_outer in range(2):
            threadIdx_x_1 = T.launch_thread("threadIdx.x", 1)
            for ax1_inner_inner in range(4):
                p0_shared_1[ax1_outer * 4 + ax1_inner_inner] = p0_1[ax1_outer * 4 + ax1_inner_inner]
    threadIdx_y_1 = T.env_thread("threadIdx.y")
    threadIdx_x_1 = T.env_thread("threadIdx.x")
    with T.launch_thread(threadIdx_y_1, 16):
        for ax0_inner in range(4):
            T.launch_thread(threadIdx_x_1, 16)
            for ax1_inner_inner in range(4):
                if threadIdx_x_1 < 2:
                    if blockIdx_y * 8 + T.shift_right(threadIdx_y_1, 1) < 125:
                        p1_shared_1[threadIdx_y_1 * 32 + ax0_inner * 8 + threadIdx_x_1 * 4 + ax1_inner_inner] = p1_1[blockIdx_y * 65536 + threadIdx_y_1 * 4096 + ax0_inner * 1024 + threadIdx_x_1 * 4 + ax1_inner_inner]
    threadIdx_y_2 = T.env_thread("threadIdx.y")
    threadIdx_x_2 = T.env_thread("threadIdx.x")
    for k_outer_outer in range(127):
        T.tvm_storage_sync("shared")
        with T.attr(p0_shared, "double_buffer_write", 1):
            T.launch_thread(threadIdx_y_2, 1)
            for ax1_outer in range(2):
                T.launch_thread(threadIdx_x_2, 1)
                for ax1_inner_inner in range(4):
                    p0_shared_1[T.bitwise_and(k_outer_outer + 1, 1) * 8 + ax1_outer * 4 + ax1_inner_inner] = p0_1[k_outer_outer * 8 + ax1_outer * 4 + ax1_inner_inner + 8]
        with T.attr(p1_shared, "double_buffer_write", 1):
            T.launch_thread(threadIdx_y_1, 16)
            for ax0_inner in range(4):
                T.launch_thread(threadIdx_x_1, 16)
                for ax1_inner_inner in range(4):
                    if threadIdx_x_1 < 2:
                        if blockIdx_y * 8 + T.shift_right(threadIdx_y_1, 1) < 125:
                            p1_shared_1[T.bitwise_and(k_outer_outer + 1, 1) * 512 + threadIdx_y_1 * 32 + ax0_inner * 8 + threadIdx_x_1 * 4 + ax1_inner_inner] = p1_1[blockIdx_y * 65536 + threadIdx_y_1 * 4096 + ax0_inner * 1024 + k_outer_outer * 8 + threadIdx_x_1 * 4 + ax1_inner_inner + 8]
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 256]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 1]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 1]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 257]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 2]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 2]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 258]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 3]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 3]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 259]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 4]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 4]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 260]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 5]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 5]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 261]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 6]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 6]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 262]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
        p0_shared_local_3[0] = p0_shared_1[T.bitwise_and(k_outer_outer, 1) * 8 + 7]
        for ax0 in range(2):
            p1_shared_local_3[ax0] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 7]
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                p1_shared_local_3[ax0 + 2] = p1_shared_1[T.bitwise_and(k_outer_outer, 1) * 512 + threadIdx_y * 16 + ax0 * 8 + 263]
        for j_c in range(2):
            T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c], T_matmul_NT_local_1[j_c])
            if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
                T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_3[0], p1_shared_local_3[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    T.tvm_storage_sync("shared")
    p0_shared_local_1[0] = p0_shared_1[8]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 512]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 768]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[9]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 513]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 769]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[10]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 514]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 770]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[11]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 515]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 771]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[12]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 516]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 772]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[13]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 517]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 773]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[14]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 518]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 774]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    p0_shared_local_1[0] = p0_shared_1[15]
    for ax0 in range(2):
        p1_shared_local_1[ax0] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 519]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            p1_shared_local_1[ax0 + 2] = p1_shared_1[threadIdx_y * 16 + ax0 * 8 + 775]
    for j_c in range(2):
        T_matmul_NT_local_1[j_c] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c], T_matmul_NT_local_1[j_c])
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_matmul_NT_local_1[j_c + 2] = T.call_llvm_pure_intrin("float32", "llvm.fmuladd", T.uint32(3), p0_shared_local_1[0], p1_shared_local_1[j_c + 2], T_matmul_NT_local_1[j_c + 2])
    for ax1_inner_inner_inner in range(2):
        T_add_1[blockIdx_y * 64 + threadIdx_y * 2 + ax1_inner_inner_inner] = T_matmul_NT_local_1[ax1_inner_inner_inner] + p2_1[blockIdx_y * 64 + threadIdx_y * 2 + ax1_inner_inner_inner]
        if blockIdx_y * 8 + T.shift_right(threadIdx_y, 2) < 121:
            T_add_1[blockIdx_y * 64 + threadIdx_y * 2 + ax1_inner_inner_inner + 32] = T_matmul_NT_local_1[ax1_inner_inner_inner + 2] + p2_1[blockIdx_y * 64 + threadIdx_y * 2 + ax1_inner_inner_inner + 32]
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_global_avg_pool2d_kernel(adaptive_pool_sum: T.handle("float32", "global"), p0: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.x", "threadIdx.y", "threadIdx.x"], "tir.noalias": T.bool(True)})
    adaptive_pool_sum_1 = T.decl_buffer((1024,), data=adaptive_pool_sum)
    red_buf0 = T.handle("float32", "shared")
    red_buf0_1 = T.decl_buffer((1024,), data=red_buf0, scope="shared")
    p0_1 = T.decl_buffer((50176,), data=p0)
    adaptive_pool_sum_rf = T.handle("float32", "local")
    adaptive_pool_sum_rf_1 = T.decl_buffer((1,), data=adaptive_pool_sum_rf, scope="local", align=4)
    blockIdx_x = T.launch_thread("blockIdx.x", 32)
    adaptive_pool_sum_rf = T.allocate([1], "float32", "local")
    red_buf0 = T.allocate([1024], "float32", "shared")
    T.attr(red_buf0, "volatile_scope", 1)
    threadIdx_y = T.launch_thread("threadIdx.y", 32)
    threadIdx_x = T.launch_thread("threadIdx.x", 32)
    adaptive_pool_sum_rf_1[0] = T.float32(0)
    for rv0_rv1_fused_outer in range(2):
        if rv0_rv1_fused_outer * 32 + threadIdx_x < 49 and rv0_rv1_fused_outer * 32 + threadIdx_x < 49:
            adaptive_pool_sum_rf_1[0] = adaptive_pool_sum_rf_1[0] + p0_1[blockIdx_x * 1568 + threadIdx_y * 49 + rv0_rv1_fused_outer * 32 + threadIdx_x]
    with T.attr(T.comm_reducer(lambda x, y: x + y, [T.float32(0)]), "reduce_scope", T.reinterpret("handle", T.uint64(0))):
        T.tvm_storage_sync("shared")
        red_buf0_1[threadIdx_y * 32 + threadIdx_x] = adaptive_pool_sum_rf_1[0]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 16:
            red_buf0_1[threadIdx_y * 32 + threadIdx_x] = red_buf0_1[threadIdx_y * 32 + threadIdx_x] + red_buf0_1[threadIdx_y * 32 + threadIdx_x + 16]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 8:
            red_buf0_1[threadIdx_y * 32 + threadIdx_x] = red_buf0_1[threadIdx_y * 32 + threadIdx_x] + red_buf0_1[threadIdx_y * 32 + threadIdx_x + 8]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 4:
            red_buf0_1[threadIdx_y * 32 + threadIdx_x] = red_buf0_1[threadIdx_y * 32 + threadIdx_x] + red_buf0_1[threadIdx_y * 32 + threadIdx_x + 4]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 2:
            red_buf0_1[threadIdx_y * 32 + threadIdx_x] = red_buf0_1[threadIdx_y * 32 + threadIdx_x] + red_buf0_1[threadIdx_y * 32 + threadIdx_x + 2]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 1:
            red_buf0_1[threadIdx_y * 32 + threadIdx_x] = red_buf0_1[threadIdx_y * 32 + threadIdx_x] + red_buf0_1[threadIdx_y * 32 + threadIdx_x + 1]
        T.tvm_storage_sync("shared")
    if threadIdx_x == 0:
        adaptive_pool_sum_1[blockIdx_x * 32 + threadIdx_y] = red_buf0_1[threadIdx_y * 32]
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_global_avg_pool2d_kernel_1(adaptive_pool_avg: T.handle("float32"), adaptive_pool_sum: T.handle("float32", "global")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.x", "threadIdx.x"], "tir.noalias": T.bool(True)})
    adaptive_pool_sum_1 = T.decl_buffer((1024,), data=adaptive_pool_sum)
    adaptive_pool_avg_1 = T.decl_buffer((1024,), data=adaptive_pool_avg)
    blockIdx_x = T.launch_thread("blockIdx.x", 4)
    threadIdx_x = T.launch_thread("threadIdx.x", 256)
    adaptive_pool_avg_1[blockIdx_x * 256 + threadIdx_x] = adaptive_pool_sum_1[blockIdx_x * 256 + threadIdx_x] * T.float32(0.020408163265306121)
[23:16:57] /src/tvm/src/target/llvm/codegen_amdgpu.cc:92: Adding PrimFunc GPU:
# from tvm.script import tir as T

@T.prim_func
def tvmgen_default_fused_nn_softmax_kernel(T_softmax_norm: T.handle("float32"), p0: T.handle("float32")):
    T.func_attr({"calling_conv": 2, "target": T.target({"device": "amd_apu", "host": {"keys": ["cpu"], "kind": "llvm", "tag": ""}, "keys": ["amd_apu", "rocm", "gpu"], "kind": "rocm", "max_num_threads": 256, "max_shared_memory_per_block": 65536, "max_threads_per_block": 256, "mcpu": "gfx906", "model": "1080ti", "mtriple": "amdgcn-amd-amdhsa-hcc", "tag": "", "thread_warp_size": 64}), "tir.is_global_func": T.bool(True), "tir.kernel_launch_params": ["blockIdx.x", "threadIdx.x"], "tir.noalias": T.bool(True)})
    T_softmax_norm_1 = T.decl_buffer((1000,), data=T_softmax_norm)
    red_buf0 = T.handle("float32", "shared")
    red_buf0_1 = T.decl_buffer((64,), data=red_buf0, scope="shared")
    normal_reduce_temp0 = T.handle("float32", "local")
    normal_reduce_temp0_1 = T.decl_buffer((1,), data=normal_reduce_temp0, scope="local")
    T_softmax_exp = T.handle("float32", "local")
    T_softmax_exp_1 = T.decl_buffer((1000,), data=T_softmax_exp, scope="local")
    red_buf0_2 = T.handle("float32", "shared")
    red_buf0_3 = T.decl_buffer((64,), data=red_buf0_2, scope="shared")
    p0_1 = T.decl_buffer((1000,), data=p0)
    normal_reduce_temp0_2 = T.handle("float32", "local")
    normal_reduce_temp0_3 = T.decl_buffer((1,), data=normal_reduce_temp0_2, scope="local")
    blockIdx_x = T.launch_thread("blockIdx.x", 1)
    normal_reduce_temp0_2 = T.allocate([1], "float32", "local")
    red_buf0_2 = T.allocate([64], "float32", "shared")
    T.attr(red_buf0_2, "volatile_scope", 1)
    T_softmax_exp = T.allocate([16], "float32", "local")
    normal_reduce_temp0 = T.allocate([1], "float32", "local")
    red_buf0 = T.allocate([64], "float32", "shared")
    T.attr(red_buf0, "volatile_scope", 1)
    threadIdx_x = T.env_thread("threadIdx.x")
    with T.launch_thread(threadIdx_x, 64):
        normal_reduce_temp0_3[0] = T.float32(-3.4028234663852886e+38)
        for k_inner in range(16):
            if threadIdx_x * 2 + T.shift_right(k_inner, 3) < 125:
                normal_reduce_temp0_3[0] = T.max(normal_reduce_temp0_3[0], p0_1[threadIdx_x * 16 + k_inner])
        with T.attr(T.comm_reducer(lambda x, y: T.max(x, y), [T.float32(-3.4028234663852886e+38)]), "reduce_scope", T.reinterpret("handle", T.uint64(0))):
            T.tvm_storage_sync("shared")
            red_buf0_3[threadIdx_x] = normal_reduce_temp0_3[0]
            T.tvm_storage_sync("shared")
            if threadIdx_x < 32:
                with T.LetStmt(T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 32])) as w_32_0:
                    T.tvm_storage_sync("warp")
                    red_buf0_3[threadIdx_x] = w_32_0
                    T.tvm_storage_sync("warp")
                with T.LetStmt(T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 16])) as w_16_0:
                    T.tvm_storage_sync("warp")
                    red_buf0_3[threadIdx_x] = w_16_0
                    T.tvm_storage_sync("warp")
                with T.LetStmt(T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 8])) as w_8_0:
                    T.tvm_storage_sync("warp")
                    red_buf0_3[threadIdx_x] = w_8_0
                    T.tvm_storage_sync("warp")
                with T.LetStmt(T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 4])) as w_4_0:
                    T.tvm_storage_sync("warp")
                    red_buf0_3[threadIdx_x] = w_4_0
                    T.tvm_storage_sync("warp")
                with T.LetStmt(T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 2])) as w_2_0:
                    T.tvm_storage_sync("warp")
                    red_buf0_3[threadIdx_x] = w_2_0
                    T.tvm_storage_sync("warp")
                w_1_0: T.float32 = T.max(red_buf0_3[threadIdx_x], red_buf0_3[threadIdx_x + 1])
                T.tvm_storage_sync("warp")
                red_buf0_3[threadIdx_x] = w_1_0
                T.tvm_storage_sync("warp")
            T.tvm_storage_sync("shared")
        for i1_inner_outer in range(4):
            if threadIdx_x * 2 + T.shift_right(i1_inner_outer, 1) < 125:
                T_softmax_exp_1[i1_inner_outer * 4:i1_inner_outer * 4 + 4] = T.call_pure_extern("float32x4", "__ocml_exp_f32", p0_1[threadIdx_x * 16 + i1_inner_outer * 4:threadIdx_x * 16 + i1_inner_outer * 4 + 4] - T.Broadcast(red_buf0_3[0], 4))
    T.launch_thread(threadIdx_x, 64)
    normal_reduce_temp0_1[0] = T.float32(0)
    T.tvm_storage_sync("warp")
    for k_inner in range(16):
        if threadIdx_x * 2 + T.shift_right(k_inner, 3) < 125:
            normal_reduce_temp0_1[0] = normal_reduce_temp0_1[0] + T_softmax_exp_1[k_inner]
    with T.attr(T.comm_reducer(lambda x, y: x + y, [T.float32(0)]), "reduce_scope", T.reinterpret("handle", T.uint64(0))):
        T.tvm_storage_sync("shared")
        red_buf0_1[threadIdx_x] = normal_reduce_temp0_1[0]
        T.tvm_storage_sync("shared")
        if threadIdx_x < 32:
            with T.LetStmt(red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 32]) as w_32_0:
                T.tvm_storage_sync("warp")
                red_buf0_1[threadIdx_x] = w_32_0
                T.tvm_storage_sync("warp")
            with T.LetStmt(red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 16]) as w_16_0:
                T.tvm_storage_sync("warp")
                red_buf0_1[threadIdx_x] = w_16_0
                T.tvm_storage_sync("warp")
            with T.LetStmt(red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 8]) as w_8_0:
                T.tvm_storage_sync("warp")
                red_buf0_1[threadIdx_x] = w_8_0
                T.tvm_storage_sync("warp")
            with T.LetStmt(red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 4]) as w_4_0:
                T.tvm_storage_sync("warp")
                red_buf0_1[threadIdx_x] = w_4_0
                T.tvm_storage_sync("warp")
            with T.LetStmt(red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 2]) as w_2_0:
                T.tvm_storage_sync("warp")
                red_buf0_1[threadIdx_x] = w_2_0
                T.tvm_storage_sync("warp")
            w_1_0: T.float32 = red_buf0_1[threadIdx_x] + red_buf0_1[threadIdx_x + 1]
            T.tvm_storage_sync("warp")
            red_buf0_1[threadIdx_x] = w_1_0
            T.tvm_storage_sync("warp")
        T.tvm_storage_sync("shared")
    for i1_inner_outer in range(4):
        if threadIdx_x * 2 + T.shift_right(i1_inner_outer, 1) < 125:
            T_softmax_norm_1[threadIdx_x * 16 + i1_inner_outer * 4:threadIdx_x * 16 + i1_inner_outer * 4 + 4] = T_softmax_exp_1[i1_inner_outer * 4:i1_inner_outer * 4 + 4] / T.Broadcast(red_buf0_1[0], 4)
--------------------------------------------------
Network Name         Mean Inference Time (std dev)
--------------------------------------------------
Traceback (most recent call last):
  File "/src/tvm/apps/benchmark/gpu_imagenet_bench.py", line 113, in <module>
    benchmark(network, target)
  File "/src/tvm/apps/benchmark/gpu_imagenet_bench.py", line 37, in benchmark
    lib = relay.build(net, target=target, params=params)
  File "/usr/local/lib/python3.10/dist-packages/tvm-0.7.0.dev6030+g4de435be7-py3.10-linux-x86_64.egg/tvm/relay/build_module.py", line 364, in build
    graph_json, runtime_mod, params = bld_mod.build(
  File "/usr/local/lib/python3.10/dist-packages/tvm-0.7.0.dev6030+g4de435be7-py3.10-linux-x86_64.egg/tvm/relay/build_module.py", line 161, in build
    self._build(
  File "/usr/local/lib/python3.10/dist-packages/tvm-0.7.0.dev6030+g4de435be7-py3.10-linux-x86_64.egg/tvm/_ffi/_ctypes/packed_func.py", line 239, in __call__
    raise_last_ffi_error()
  File "/usr/local/lib/python3.10/dist-packages/tvm-0.7.0.dev6030+g4de435be7-py3.10-linux-x86_64.egg/tvm/_ffi/base.py", line 481, in raise_last_ffi_error
    raise py_err
tvm._ffi.base.TVMError: Traceback (most recent call last):
  8: tvm::runtime::PackedFuncObj::Extractor<tvm::runtime::PackedFuncSubObj<tvm::relay::backend::RelayBuildModule::GetFunction(tvm::runtime::String const&, tvm::runtime::ObjectPtr<tvm::runtime::Object> const&)::{lambda(tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)#3}> >::Call(tvm::runtime::PackedFuncObj const*, tvm::runtime::TVMArgs, tvm::runtime::TVMRetValue*)
  7: tvm::relay::backend::RelayBuildModule::BuildRelay(tvm::IRModule, tvm::runtime::String const&)
  6: tvm::TIRToRuntime(tvm::runtime::Map<tvm::Target, tvm::IRModule, void, void> const&, tvm::Target const&)
  5: tvm::codegen::Build(tvm::IRModule, tvm::Target)
  4: _ZN3tvm7runtime13PackedFuncObj
  3: tvm::runtime::TypedPackedFunc<tvm::runtime::Module (tvm::IRModule, tvm::Target)>::AssignTypedLambda<tvm::runtime::Module (*)(tvm::IRModule, tvm::Target)>(tvm::runtime::Module (*)(tvm::IRModule, tvm::Target), std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)::{lambda(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*)#1}::operator()(tvm::runtime::TVMArgs const&, tvm::runtime::TVMRetValue*) const
  2: tvm::codegen::BuildAMDGPU(tvm::IRModule, tvm::Target)
  1: tvm::codegen::CodeGenLLVM::Finish()
  0: tvm::codegen::CodeGenLLVM::Verify() const
  File "/src/tvm/src/target/llvm/codegen_llvm.cc", line 355
TVMError: LLVM module verification failed with the following errors: 
Instruction does not dominate all uses!
  %29 = call i32 @llvm.amdgcn.workitem.id.x()
  %83 = icmp slt i32 %29, 2
Instruction does not dominate all uses!
  %29 = call i32 @llvm.amdgcn.workitem.id.x()
  %90 = mul nsw i32 %29, 4
Instruction does not dominate all uses!
  %29 = call i32 @llvm.amdgcn.workitem.id.x()
  %103 = mul nsw i32 %29, 4

